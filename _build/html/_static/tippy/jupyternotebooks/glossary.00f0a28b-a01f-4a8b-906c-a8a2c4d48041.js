selector_to_html = {"a[href=\"https://en.wikipedia.org/wiki/Central_processing_unit\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/0/0a/Intel_i9-14900KF_CPU.jpg/330px-Intel_i9-14900KF_CPU.jpg\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p>A <b>central processing unit</b> (<b>CPU</b>), also called a <b>central processor</b>, <b>main processor</b>, or just <b>processor</b>, is the primary processor in a given computer. Its electronic circuitry executes instructions of a computer program, such as arithmetic, logic, controlling, and input/output (I/O) operations. This role contrasts with that of external components, such as main memory and I/O circuitry, and specialized coprocessors such as graphics processing units (GPUs).</p>", "a[href^=\"https://en.wikipedia.org/wiki/Central_processing_unit#\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/0/0a/Intel_i9-14900KF_CPU.jpg/330px-Intel_i9-14900KF_CPU.jpg\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p>A <b>central processing unit</b> (<b>CPU</b>), also called a <b>central processor</b>, <b>main processor</b>, or just <b>processor</b>, is the primary processor in a given computer. Its electronic circuitry executes instructions of a computer program, such as arithmetic, logic, controlling, and input/output (I/O) operations. This role contrasts with that of external components, such as main memory and I/O circuitry, and specialized coprocessors such as graphics processing units (GPUs).</p>", "a[href=\"https://en.wikipedia.org/wiki/Camel_case\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/c/c8/CamelCase_new.svg/330px-CamelCase_new.svg.png\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p>The writing format <b>camel case</b> is the practice of writing phrases without spaces or punctuation and with capitalized words. The format indicates the first word starting with either case, then the following words having an initial uppercase letter. Common examples include <i>YouTube</i>, <i>PowerPoint</i>, <i>HarperCollins</i>, <i>FedEx</i>, <i>iPhone</i>, <i>eBay</i>, and <i>LaGuardia</i>. Camel case is often used as a naming convention in computer programming. It is also sometimes used in online usernames such as <i>JohnSmith</i>, and to make multi-word domain names more legible, for example in promoting <i>EasyWidgetCompany.com</i>.</p>", "a[href^=\"https://en.wikipedia.org/wiki/Camel_case#\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/c/c8/CamelCase_new.svg/330px-CamelCase_new.svg.png\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p>The writing format <b>camel case</b> is the practice of writing phrases without spaces or punctuation and with capitalized words. The format indicates the first word starting with either case, then the following words having an initial uppercase letter. Common examples include <i>YouTube</i>, <i>PowerPoint</i>, <i>HarperCollins</i>, <i>FedEx</i>, <i>iPhone</i>, <i>eBay</i>, and <i>LaGuardia</i>. Camel case is often used as a naming convention in computer programming. It is also sometimes used in online usernames such as <i>JohnSmith</i>, and to make multi-word domain names more legible, for example in promoting <i>EasyWidgetCompany.com</i>.</p>", "a[href=\"https://en.wikipedia.org/wiki/Binary_code\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/a/af/Binary_to_Hexadecimal_or_Decimal.jpg\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p>A <b>binary code</b> is the value of a data-encoding convention represented in a binary notation that usually is a sequence of 0s and 1s; sometimes called a <i>bit string</i>. For example, ASCII is an 8-bit text encoding that in addition to the human readable form (letters) can be represented as binary. <i>Binary code</i> can also refer to the mass noun <i>code</i> that is not human readable in nature such as machine code and bytecode.</p>", "a[href^=\"https://en.wikipedia.org/wiki/Binary_code#\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/a/af/Binary_to_Hexadecimal_or_Decimal.jpg\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p>A <b>binary code</b> is the value of a data-encoding convention represented in a binary notation that usually is a sequence of 0s and 1s; sometimes called a <i>bit string</i>. For example, ASCII is an 8-bit text encoding that in addition to the human readable form (letters) can be represented as binary. <i>Binary code</i> can also refer to the mass noun <i>code</i> that is not human readable in nature such as machine code and bytecode.</p>", "a[href=\"#term-Exception\"]": "<dt id=\"term-Exception\">Exception</dt><dd><p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">std::exception</span></code> class provides methods for dealing with errors using the <code class=\"docutils literal notranslate\"><span class=\"pre\">throw</span></code> expression. Includes <code class=\"docutils literal notranslate\"><span class=\"pre\">std::bad_alloc</span></code> thrown when memory allocation fails, <code class=\"docutils literal notranslate\"><span class=\"pre\">std::bad_cast</span></code> thrown when a dynamic_cast fails during runtime, <code class=\"docutils literal notranslate\"><span class=\"pre\">std::bad_typeid</span></code> thrown when attempting to use typeid on a null pointer to a polymorphic type, <code class=\"docutils literal notranslate\"><span class=\"pre\">std::bad_exception</span></code> used to handle unexpected exceptions in a program, <code class=\"docutils literal notranslate\"><span class=\"pre\">std::logic_error</span></code> represents errors that can be detected before runtime, <code class=\"docutils literal notranslate\"><span class=\"pre\">std::invalid_argument</span></code> thrown when an invalid argument is passed to a function, <code class=\"docutils literal notranslate\"><span class=\"pre\">std::domain_error</span></code> thrown when a mathematically invalid domain is used, <code class=\"docutils literal notranslate\"><span class=\"pre\">std::length_error</span></code> thrown when an operation exceeds the maximum allowable size, <code class=\"docutils literal notranslate\"><span class=\"pre\">std::out_of_range</span></code>thrown when an argument is outside the expected range.</p></dd>", "a[href=\"#term-Reserved-Characters\"]": "<dt id=\"term-Reserved-Characters\">Reserved Characters</dt><dd><p>Some characters cannot be freely used because they have special meaning in the syntax. Some may be overloaded. Examples: <code class=\"docutils literal notranslate\"><span class=\"pre\">#</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">\\</span></code>, arithmetic operators, comparison operators, punctuation symbols.</p></dd>", "a[href=\"#term-Function-Argument\"]": "<dt id=\"term-Function-Argument\">Function-Argument</dt><dd><p>The values passed into a function. The function declaration specifies the number and type of the required arguments, which must be matched by each call to that function.</p></dd>", "a[href=\"#term-Initialiser\"]": "<dt id=\"term-Initialiser\">Initialiser</dt><dd><p>The syntax used to initialise a new variable.</p></dd>", "a[href=\"#term-Entities\"]": "<dt id=\"term-Entities\">Entities</dt><dd><p>The entities of a C++ program are values, objects, references, functions, enumerators, types, class members, templates, template specializations, and namespaces</p></dd>", "a[href=\"#term-Namespace\"]": "<dt id=\"term-Namespace\">Namespace</dt><dd><p>Entities declared inside a namespace block are placed in a namespace <a class=\"reference internal\" href=\"#term-Scope\"><span class=\"xref std std-term\">scope</span></a>, which prevents them from being mistaken for identically named entities in other scopes. Entities declared outside a namespace are in the global namespace. Users may define namespaces.</p></dd>", "a[href=\"#term-Dereferencing\"]": "<dt id=\"term-Dereferencing\">Dereferencing</dt><dd><p>Returning the value of the object associated with a pointer - accomplished by prefixing <code class=\"docutils literal notranslate\"><span class=\"pre\">*</span></code> to the pointer\u2019s identifier in an expression.</p></dd>", "a[href=\"#term-Code-Block\"]": "<dt id=\"term-Code-Block\">Code-Block</dt><dd><p>Sequence of <a class=\"reference internal\" href=\"#term-Statements\"><span class=\"xref std std-term\">statements</span></a> enclosed by curly braces <code class=\"docutils literal notranslate\"><span class=\"pre\">{}</span></code>. Also referred to as a <a class=\"reference internal\" href=\"#term-Compound-Statement\"><span class=\"xref std std-term\">compound statement</span></a>.</p></dd>", "a[href=\"#term-Compound-Type\"]": "<dt id=\"term-Compound-Type\">Compound Type</dt><dd><p>A type that isn\u2019t a <a class=\"reference internal\" href=\"#term-Scalar\"><span class=\"xref std std-term\">scalar</span></a> type. Compound types include array types, function types, class (or struct) types, union types, enumerations, references, and pointers to non-static class members.</p></dd>", "a[href=\"#term-Implementation\"]": "<dt id=\"term-Implementation\">Implementation</dt><dd><p>Different versions of C++, produced by different organisations. Some behaviours are defined by the ISO C++ Standard, others depend on the implementation.</p></dd>", "a[href=\"#term-Keywords\"]": "<dt id=\"term-Keywords\">Keywords</dt><dd><p>An identifier used by the C++ language standard. Keywords are reserved; they may not be declared as an identifier by a programr. <a class=\"reference external\" href=\"https://en.cppreference.com/w/cpp/keywords.html\">Keywords in the C++ language</a>.</p></dd>", "a[href=\"#term-Control-Flow-Statements\"]": "<dt id=\"term-Control-Flow-Statements\">Control Flow Statements</dt><dd><p>Selection and iteration statements: <code class=\"docutils literal notranslate\"><span class=\"pre\">if</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">switch</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">for</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">while</span></code>etc.</p></dd>", "a[href=\"#term-1\"]": "<dt id=\"term-1\">Function Call</dt><dd><p>A function is \u2018called\u2019 or \u2018invoked\u2019 by a statement of the function name followed by the values to be passed to the function in parenthesis. Any value returned by the function can be used by <a class=\"reference internal\" href=\"#term-Copy-Assignment\"><span class=\"xref std std-term\">copy-assignment</span></a>.</p></dd>", "a[href=\"#term-Stack\"]": "<dt id=\"term-Stack\">Stack</dt><dd></dd>", "a[href=\"#term-Compiler\"]": "<dt id=\"term-Compiler\">Compiler</dt><dd><p>The part of a C++ implementation that produces object code from a translation unit. Compilers transform source code into other types of code - most often, into native machine code that is interpreted directly by the <a class=\"reference internal\" href=\"#term-CPU\"><span class=\"xref std std-term\">CPU</span></a>.</p></dd>", "a[href=\"#term-prvalue\"]": "<dt id=\"term-prvalue\">prvalue</dt><dd><p>\u2018pure <a class=\"reference internal\" href=\"#term-rvalue\"><span class=\"xref std std-term\">rvalue</span></a>\u2019 expressions including literals, function calls, arithmetic and logical evaluations and comparisons, whose evaluation computes the value of an operand of a built-in operator (no result object) or initializes an object (a result object is created). The result object may be a variable, an object created by new-expression, or a \u2018temporary\u2019 created by temporary materialization.</p></dd>", "a[href=\"#term-Static-Duration\"]": "<dt id=\"term-Static-Duration\">Static Duration</dt><dd><p>Lifetime of the program\u2019s execution - duration of static variables - all global variables.</p></dd>", "a[href=\"#term-Loop-Variable\"]": "<dt id=\"term-Loop-Variable\">Loop-Variable</dt><dd><p>Variable declared within the for-statement argument. May be used as a local variable and cannot be shadowed.</p></dd>", "a[href=\"#term-Constructors\"]": "<dt id=\"term-Constructors\">Constructors</dt><dd><p>Special member functions that are automatically called when an object of its class is created. Constructors have the same name as their class and have no return type.</p></dd>", "a[href=\"#term-Default-Initialisation\"]": "<dt id=\"term-Default-Initialisation\">Default-Initialisation</dt><dd><p>When an object of class type is constructed with no initialiser, a default constructer (if available) will initialise the object - often to empty - but possibly to some pre-defined default value.</p></dd>", "a[href=\"#term-Templates\"]": "<dt id=\"term-Templates\">Templates</dt><dd><p>A blueprint for generic and reusable code for functions and classes.</p></dd>", "a[href=\"#term-Scopes\"]": "<dt id=\"term-Scopes\">Scopes</dt><dd><p>The context in which a variable, function, or class is defined. May be global, namespace, class, function, block/local.</p></dd>", "a[href=\"#term-Containers\"]": "<dt id=\"term-Containers\">Containers</dt><dd><p>A container is an object used to store other objects and to take care of the management of the memory used by the objects it contains.</p></dd>", "a[href=\"#term-Null\"]": "<dt id=\"term-Null\">Null</dt><dd><p>The integer constant zero.</p></dd>", "a[href=\"#term-Empty-Statement\"]": "<dt id=\"term-Empty-Statement\">Empty Statement</dt><dd><p>A statement that consists of only a semicolon <code class=\"docutils literal notranslate\"><span class=\"pre\">;</span></code>. It does nothing and is often referred to as a <a class=\"reference internal\" href=\"#term-Null-Statement\"><span class=\"xref std std-term\">null statement</span></a>. Empty statements are used where the syntax requires a statement, but the contents are optionally not required, to provide an empty body to a <code class=\"docutils literal notranslate\"><span class=\"pre\">for</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">while</span></code> loop, or to carry a label at the end of a compound statement.</p></dd>", "a[href=\"#term-Floating-Point-Numbers\"]": "<dt id=\"term-Floating-Point-Numbers\">Floating-Point Numbers</dt><dd><p>Numbers with a decimal point. Represented in code by the addition of <code class=\"docutils literal notranslate\"><span class=\"pre\">.0</span></code> to whole numbers.</p></dd>", "a[href=\"#term-For-Statement\"]": "<dt id=\"term-For-Statement\">For-Statement</dt><dd><p>Iteration statement - controls the repeated execution of code block while a condition is true. May use a loop variable and can run a final statement that may increment the loop variable.</p></dd>", "a[href=\"#term-Global-Scope\"]": "<dt id=\"term-Global-Scope\">Global Scope</dt><dd><p>Variables declared outside of all functions and classes have global scope. Global variables are accessible throughout the program, unless \u2018shadowed\u2019 by a local variable with the same name. Global variables are best avoided unless necessary because they may result in unintended consequences in execution.</p></dd>", "a[href=\"#term-Name\"]": "<dt id=\"term-Name\">Name</dt><dd><p>An identifier. (A minority of names are not identifiers - advanced).</p></dd>", "a[href=\"#term-Header-Files\"]": "<dt id=\"term-Header-Files\">Header Files</dt><dd><p>Header files in C++ are essential for organizing and managing code in large projects. They contain declarations of functions, classes, variables, and other identifiers, that inform the compiler about the existence and type of these elements without providing their actual implementation. This separation allows multiple source files to share the same declarations, ensuring consistency and reducing errors, and include them wherever needed, reducing redundancy and improving code maintainability.</p></dd>", "a[href=\"#term-New\"]": "<dt id=\"term-New\">New</dt><dd><p>Keyword in C++ used to dynamically allocate memory on the heap for objects or variables during runtime. <code class=\"docutils literal notranslate\"><span class=\"pre\">new</span></code> allocates the required amount of memory on the heap; and calls a constructor (if there is one) to initialise the newly allocated object/memory.</p></dd>", "a[href=\"#term-Type-Conversion\"]": "<dt id=\"term-Type-Conversion\">Type Conversion</dt><dd><p>Alternative name for type casting.</p></dd>", "a[href=\"#term-Numeric-Data-Type\"]": "<dt id=\"term-Numeric-Data-Type\">Numeric Data Type</dt><dd><p>The data types for numeric values - each represents a different type of number to different levels of precision. Includes <code class=\"docutils literal notranslate\"><span class=\"pre\">int</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">float</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">double</span></code>. Some data types require additional specifiers, see the <a class=\"reference external\" href=\"https://en.cppreference.com/w/cpp/language/types.html\">C++ Reference \u2013 Data Types</a></p></dd>", "a[href=\"#term-Indirection\"]": "<dt id=\"term-Indirection\">Indirection</dt><dd><p>Returning the value of the object associated with a pointer - accomplished by prefixing <code class=\"docutils literal notranslate\"><span class=\"pre\">*</span></code> to the pointer\u2019s identifier in an expression.</p></dd>", "a[href=\"#term-Passed-by-reference\"]": "<dt id=\"term-Passed-by-reference\">Passed by reference</dt><dd><p>Passing a reference to a variable as the argument of a function call. Allows the modification of that variable by the function.</p></dd>", "a[href=\"#term-Enumerations\"]": "<dt id=\"term-Enumerations\">Enumerations</dt><dd><p>User-defined type consisting of a set of named values.</p></dd>", "a[href=\"#term-Constant\"]": "<dt id=\"term-Constant\">Constant</dt><dd><p>A variable or function parameter that is immutable - the value cannot be changed after it has been initialised. Set using the <code class=\"docutils literal notranslate\"><span class=\"pre\">const</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">constexpr</span></code> modifiers at declaration.</p></dd>", "a[href=\"#term-Data-Member\"]": "<dt id=\"term-Data-Member\">Data Member</dt><dd><p>Member of a class that can hold a value.</p></dd>", "a[href=\"#term-Namespaces\"]": "<dt id=\"term-Namespaces\">Namespaces</dt><dd><p>Namespaces are used to organise programmes in more manageable sections by providing a method for preventing name conflicts in large projects.</p></dd>", "a[href=\"#term-For-loop\"]": "<dt id=\"term-For-loop\">For-loop</dt><dd><p>Common name for the for-statement.</p></dd>", "a[href=\"#term-Values\"]": "<dt id=\"term-Values\">Values</dt><dd><p>Literals stored in a variable. Other usages -  see <a class=\"reference internal\" href=\"#term-Value-Categories\"><span class=\"xref std std-term\">Value Categories</span></a>.</p></dd>", "a[href=\"#term-Compound-Assignment\"]": "<dt id=\"term-Compound-Assignment\">Compound-Assignment</dt><dd><p>Replaces the contents of the LHS object with the result of a binary operation between the previous value of LHS and the value of RHS e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">A</span> <span class=\"pre\">=</span> <span class=\"pre\">A</span> <span class=\"pre\">+</span> <span class=\"pre\">B</span></code>.</p></dd>", "a[href=\"#term-3\"]": "<dt id=\"term-3\">Void*</dt><dd><p>A pointer\u2019s type - if <code class=\"docutils literal notranslate\"><span class=\"pre\">void*</span></code>, the pointer can point to any variable that\u2019s not declared with the <code class=\"docutils literal notranslate\"><span class=\"pre\">const</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">volatile</span></code> keyword. A void* pointer can\u2019t be dereferenced unless it\u2019s cast to another type. A void* pointer can be converted into any other type of data pointer. A void* pointer can point to a free function (a function that\u2019s not a member of a class), or to a static member function, but not to a non-static member function.</p></dd>", "a[href=\"#term-Literal-assignment\"]": "<dt id=\"term-Literal-assignment\">Literal-assignment</dt><dd><p>Uses a literal for the RHS in assignment expression.</p></dd>", "a[href=\"#term-Output\"]": "<dt id=\"term-Output\">Output</dt><dd><p>Output refers to data sent from a computer or electronic device, such as audio, graphics, text, and video. Output devices convert the data processed by a computer into a human-understandable form.</p></dd>", "a[href=\"#term-Construction\"]": "<dt id=\"term-Construction\">Construction</dt><dd><p>Creating a new object \u2013 also called instantiation, when referring to a class.</p></dd>", "a[href=\"#term-Variables\"]": "<dt id=\"term-Variables\">Variables</dt><dd><p>A variable is a named object, or a reference that is not a non-static data member, that is introduced by a declaration, in a scope.</p></dd>", "a[href=\"#term-Binary\"]": "<dt id=\"term-Binary\">Binary</dt><dd><p><a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Binary_code\">Binary Code</a> is a sequence of 1\u2019s and 0\u2019s. Each <code class=\"docutils literal notranslate\"><span class=\"pre\">1</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">0</span></code> is called a bit. A computer will read a specific number of bits (e.g. 64) at a time. Different sequences of bits represent different instructions to the CPU.</p></dd>", "a[href=\"#term-Objects\"]": "<dt id=\"term-Objects\">Objects</dt><dd></dd>", "a[href=\"#term-Identifier\"]": "<dt id=\"term-Identifier\">Identifier</dt><dd><p>The <a class=\"reference internal\" href=\"#term-Name\"><span class=\"xref std std-term\">name</span></a> given to any <a class=\"reference internal\" href=\"#term-Entity\"><span class=\"xref std std-term\">entity</span></a> that may have a used defined name.</p></dd>", "a[href=\"#glossary\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Glossary<a class=\"headerlink\" href=\"#glossary\" title=\"Permalink to this heading\">#</a></h1>", "a[href=\"#term-Passed-by-Value\"]": "<dt id=\"term-Passed-by-Value\">Passed by Value</dt><dd><p>Passing a variable name into a function, which results in a local copy of the variable being created that may be used within the function, preserving the original.</p></dd>", "a[href=\"#term-String-Data-Type\"]": "<dt id=\"term-String-Data-Type\">String Data Type</dt><dd><p>Data consisting of a sequence of characters, bracketed by <code class=\"docutils literal notranslate\"><span class=\"pre\">\"\"</span></code>. Requires inclusion of <code class=\"docutils literal notranslate\"><span class=\"pre\">&lt;string&gt;</span></code> and access via <code class=\"docutils literal notranslate\"><span class=\"pre\">std::</span></code> namespace scope.</p></dd>", "a[href=\"#term-Null-Character\"]": "<dt id=\"term-Null-Character\">Null Character</dt><dd><p>The null character is a control character represented by escape sequence \u2018\\0\u2019 that has an integer value of 0. May be used to signify the end of a string in C-style strings (character arrays). \u2018\\0\u2019 is a character literal with a value of 0. Can also represent the <code class=\"docutils literal notranslate\"><span class=\"pre\">nullptr</span></code> for comparison expressions. The null character is stored as a byte (8 bits) with all bits set to zero.</p></dd>", "a[href=\"#term-Memory-Management\"]": "<dt id=\"term-Memory-Management\">Memory Management</dt><dd><p>Methods of allocating and freeing memory. In C++ memory is either static, allocated on the stack, or allocated on the free store. When people talk about memory management, they usually refer to the free store or to \u2018garbage collection\u2019. Memory can often be effectively managed through standard library containers, such as <code class=\"docutils literal notranslate\"><span class=\"pre\">vector</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">string</span></code>, or through general resource management techniques.</p></dd>", "a[href=\"#term-Translation-units\"]": "<dt id=\"term-Translation-units\">Translation units</dt><dd><p>Part of a program that can be separately compiled. Individual source, or header, files.</p></dd>", "a[href=\"#term-Type-Safety\"]": "<dt id=\"term-Type-Safety\">Type Safety</dt><dd><p>The property that an object can be accessed only according to its definition. C++ is highly type safe, but a programmer can still violate type safety by explicit casting, by using an uninitialized variable, by using a pointer that doesn\u2019t point to an object, by accessing beyond the end of an array, and by misusing a union. Type safety must be preserved for a program to be correct and maintainable.</p></dd>", "a[href=\"#term-0\"]": "<dt id=\"term-0\">Copy Assignment</dt><dd><p>Replacement of the contents of one object with the contents of a second object; the second object is unaffected by the operation. Can also initialise an object.</p></dd>", "a[href=\"#term-Integer-type\"]": "<dt id=\"term-Integer-type\">Integer type</dt><dd><p>Type for integer values (whole numbers - positive and negative and zero). May be preceded by one or two modifiers - <code class=\"docutils literal notranslate\"><span class=\"pre\">signed</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">unsigned</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">short</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">long</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">long</span> <span class=\"pre\">long</span></code>. The modifiers may be used on their own, and <code class=\"docutils literal notranslate\"><span class=\"pre\">int</span></code> is implied; but <code class=\"docutils literal notranslate\"><span class=\"pre\">signed</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">unsigned</span></code> may also precede <code class=\"docutils literal notranslate\"><span class=\"pre\">char</span></code>.</p></dd>", "a[href=\"#term-Preprocessor\"]": "<dt id=\"term-Preprocessor\">Preprocessor</dt><dd><p>Before the source code is passed to the compiler, the preprocessor handles directives (#include, #define, and #ifdef), replacing macros and copying the contents of libraries and header files into the source file, and removing any comments - to create a modified/preprocessed source file that is ready to be compiled.</p></dd>", "a[href=\"#term-Constructor\"]": "<dt id=\"term-Constructor\">Constructor</dt><dd><p>A special member function that is automatically called when an object of its class is created. Constructors have the same name as their class and have no return type (not even <code class=\"docutils literal notranslate\"><span class=\"pre\">void</span></code>).</p></dd>", "a[href=\"#term-initialiser-List\"]": "<dt id=\"term-initialiser-List\">initialiser List</dt><dd><p>A comma-delimited list of expressions enclosed in curly braces <code class=\"docutils literal notranslate\"><span class=\"pre\">{}</span></code>; used to initialize a <code class=\"docutils literal notranslate\"><span class=\"pre\">struct</span></code> or an array.</p></dd>", "a[href=\"#term-Shadowing\"]": "<dt id=\"term-Shadowing\">Shadowing</dt><dd><p>For variables with the same name, the inner most scope is dominant, i.e. a local variable is used in preference to a global variable with the same name. The inner scope variable is said to shadow the outer scope variable.</p></dd>", "a[href=\"#term-Embedded-Programmes\"]": "<dt id=\"term-Embedded-Programmes\">Embedded Programmes</dt><dd><p>Programmes written on computers and then transferred onto an embedded microprocessor in a device to control its function - also called firmware. The embedded program is an integrated part of the device and not directly accessible by the user.</p></dd>", "a[href=\"#term-Object-oriented-programming\"]": "<dt id=\"term-Object-oriented-programming\">Object-oriented programming</dt><dd><p>Programming paradigm that encapsulates related data and functions into objects. An imperative model, focusing on \u201chow to do\u201d tasks step-by-step.</p></dd>", "a[href=\"#term-Enumeration\"]": "<dt id=\"term-Enumeration\">Enumeration</dt><dd><p>User-defined type consisting of a set of named values.</p></dd>", "a[href=\"#term-Declaration\"]": "<dt id=\"term-Declaration\">Declaration</dt><dd><p>Declarations introduce names/identifiers into a C++ program. Each kind of entity is declared differently.</p></dd>", "a[href=\"#term-Template\"]": "<dt id=\"term-Template\">Template</dt><dd><p>A blueprint for generic and reusable code for functions and classes.</p></dd>", "a[href=\"#term-Null-Statement\"]": "<dt id=\"term-Null-Statement\">Null Statement</dt><dd><p>The <a class=\"reference internal\" href=\"#term-Empty-Statement\"><span class=\"xref std std-term\">Empty statement</span></a>: valid in C++ and can be used in certain scenarios where a statement is syntactically required but no action is needed.</p></dd>", "a[href=\"#term-Expression-Statements\"]": "<dt id=\"term-Expression-Statements\">Expression Statements</dt><dd><p>An expression followed by a semicolon.</p></dd>", "a[href=\"#term-Keyword\"]": "<dt id=\"term-Keyword\">Keyword</dt><dd><p>An identifier used by the C++ language standard. Keywords are reserved; they may not be declared as an identifier by a programr. <a class=\"reference external\" href=\"https://en.cppreference.com/w/cpp/keywords.html\">Keywords in the C++ language</a>.</p></dd>", "a[href=\"#term-Escape-Sequences\"]": "<dt id=\"term-Escape-Sequences\">Escape Sequences</dt><dd><p>Used in programming languages to represent special characters within a string or character literal. They are identified by the prefix backslash <code class=\"docutils literal notranslate\"><span class=\"pre\">\\</span></code>. Examples are <code class=\"docutils literal notranslate\"><span class=\"pre\">\\n</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">\\t</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">\\\\</span></code> to represent \u2018newline\u2019, \u2018tab\u2019 - and to identify that a backslash is simply a back slash literal.</p></dd>", "a[href=\"#term-Resource-files\"]": "<dt id=\"term-Resource-files\">Resource files</dt><dd><p>Files that do not contain computer code, such as image files, required by the program.</p></dd>", "a[href=\"#term-Function-Identifier\"]": "<dt id=\"term-Function-Identifier\">Function-Identifier</dt><dd><p>Identifier of a function.</p></dd>", "a[href=\"#term-Variable\"]": "<dt id=\"term-Variable\">Variable</dt><dd><p>A variable is a named object, or a reference that is not a non-static data member, that is introduced by a declaration, in a scope.</p></dd>", "a[href=\"#term-Directive\"]": "<dt id=\"term-Directive\">Directive</dt><dd><p>Also known as preprocessor directives - instructions that are processed before compilation of the C++ code begins. Directives start with <code class=\"docutils literal notranslate\"><span class=\"pre\">#</span></code> and must lie at the top of the document. Used for including files, such as libraries, and defining <a class=\"reference internal\" href=\"#term-Macros\"><span class=\"xref std std-term\">macros</span></a>, and conditional compilation (<code class=\"docutils literal notranslate\"><span class=\"pre\">#if</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">#ifdef</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">#ifndef</span></code>).</p></dd>", "a[href=\"#term-Free-store\"]": "<dt id=\"term-Free-store\">Free store</dt><dd><p><a class=\"reference internal\" href=\"#term-Memory\"><span class=\"xref std std-term\">memory</span></a> allocated by <code class=\"docutils literal notranslate\"><span class=\"pre\">new</span></code>; also called <a class=\"reference internal\" href=\"#term-Dynamic-Memory\"><span class=\"xref std std-term\">dynamic memory</span></a>. Dynamic memory is an amount of memory of indeterminate size used up during execution of a program as new objects are created. Often standard library facilities, such as <code class=\"docutils literal notranslate\"><span class=\"pre\">vector</span></code>, can be used to avoid explicit use of the free store.</p></dd>", "a[href=\"#term-Function-Declaration\"]": "<dt id=\"term-Function-Declaration\">Function Declaration</dt><dd><p>Statement of the name, types of any arguments, and the return type of a function.</p></dd>", "a[href=\"#term-Terminator\"]": "<dt id=\"term-Terminator\">Terminator</dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">;</span></code> or {} - which close statements.</p></dd>", "a[href=\"#term-Named-Object\"]": "<dt id=\"term-Named-Object\">Named Object</dt><dd><p>A variable.</p></dd>", "a[href=\"#term-Type-Casting\"]": "<dt id=\"term-Type-Casting\">Type Casting</dt><dd><p>Assigning a value of a different type to an object of a new type. Casting/conversion can be implicit or explicit.</p></dd>", "a[href=\"#term-Definitions\"]": "<dt id=\"term-Definitions\">Definitions</dt><dd><p>Definitions are declarations that are sufficient to use the entity identified by the name \u2013 entities may only be used after initialisation, so definition is basically declaration and initialisation combined.</p></dd>", "a[href=\"#term-Translation-unit\"]": "<dt id=\"term-Translation-unit\">Translation unit</dt><dd><p>Part of a program that can be separately compiled. Individual source, or header, files.</p></dd>", "a[href=\"#term-Function-Call\"]": "<dt id=\"term-Function-Call\">Function-Call</dt><dd><p>A function is \u2018called\u2019 or \u2018invoked\u2019 by a statement of the function name followed by the values to be passed to the function in parentheses. Any value returned by the function can be used by <a class=\"reference internal\" href=\"#term-Copy-Assignment\"><span class=\"xref std std-term\">copy-assignment</span></a>.</p></dd>", "a[href=\"#term-Executable-File\"]": "<dt id=\"term-Executable-File\">Executable File</dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">.exe</span></code> or other file types that contain machine code computer programmes that run directly on the computer\u2019s processor.</p></dd>", "a[href=\"#term-Input\"]": "<dt id=\"term-Input\">Input</dt><dd><p>The process of sending data or instructions to a computer system for processing. The data comes from input devices. The computer\u2019s CPU processes the input to generate meaningful <a class=\"reference internal\" href=\"#term-Output\"><span class=\"xref std std-term\">output</span></a>.</p></dd>", "a[href=\"#term-Declarator-operators\"]": "<dt id=\"term-Declarator-operators\">Declarator-operators</dt><dd><p>Operators used to modify the type of a variable, function, or object being declared. e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">*</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">&amp;</span></code> for pointers, and <code class=\"docutils literal notranslate\"><span class=\"pre\">[]</span></code> for arrays.</p></dd>", "a[href=\"#term-lvalue\"]": "<dt id=\"term-lvalue\">lvalue</dt><dd><p>An expression whose evaluation determines the identity of an object or function. The name of the object or function - basically, the left-hand side of an assignment operation or the name before the {}.</p></dd>", "a[href=\"#term-Binary-File\"]": "<dt id=\"term-Binary-File\">Binary File</dt><dd><p>File containing only binary code.</p></dd>", "a[href=\"#term-Print-Debugging\"]": "<dt id=\"term-Print-Debugging\">Print Debugging</dt><dd><p>Using strategically positioned print statements to follow the control flow of a program\u2019s execution. The print statements may just include an index to identify which statement produced it, or more detailed error/exception outputs.</p></dd>", "a[href=\"#term-Algorithm\"]": "<dt id=\"term-Algorithm\">Algorithm</dt><dd><p>Algorithm: A sequence of steps or rules to solve a problem, often implemented using STL (Standard Template Library).</p></dd>", "a[href=\"#term-Machine-Code\"]": "<dt id=\"term-Machine-Code\">Machine Code</dt><dd><p>Computer programmes encoded and structured to run directly on a computer\u2019s hardware. The different <a class=\"reference internal\" href=\"#term-CPU\"><span class=\"xref std std-term\">CPU</span></a> architectures, x86, ARM, Apple Silicon, have different programmable interfaces and require different machine code specified by an <a class=\"reference internal\" href=\"#term-Instruction-Set-Architecture\"><span class=\"xref std std-term\">instruction set architecture</span></a>.</p></dd>", "a[href=\"#term-Return-statement\"]": "<dt id=\"term-Return-statement\">Return-statement</dt><dd><p>Statement that causes a function call to end, returning control to the program/function that made the call, possibly sending a value back to the caller.</p></dd>", "a[href=\"#term-Casting-to-Type\"]": "<dt id=\"term-Casting-to-Type\">Casting to Type</dt><dd><p>Conversion of one type of data safely to another. A variable cannot change its type, so type casting occurs on assignment to a variable of the correct type.</p></dd>", "a[href=\"#term-Iteration\"]": "<dt id=\"term-Iteration\">Iteration</dt><dd><p>Iteration means repetition. In computing the same set of instructions, possibly with variations in values, often need to be repeated. Iteration statements are used to instruct the program to repeat a sequence of statements a variable number of times.</p></dd>", "a[href=\"#term-Function\"]": "<dt id=\"term-Function\">Function</dt><dd><p>A named sequence of statements that can be invoked/called by a program, optionally using arguments supplied by the function call, to optionally return a value to the program. The type of the function includes the comma separated list of the types of its argument and the type of the value returned. Functions are useful because they are reusable, making code more efficient to write and execute. Functions can be identified by a name with <code class=\"docutils literal notranslate\"><span class=\"pre\">()</span></code>attached.</p></dd>", "a[href=\"#term-Class-Members\"]": "<dt id=\"term-Class-Members\">Class Members</dt><dd><p>Functions that belong to a class.</p></dd>", "a[href=\"#term-Const\"]": "<dt id=\"term-Const\">Const</dt><dd><p>A keyword that makes a variable or function parameter immutable.</p></dd>", "a[href=\"#term-Object-files\"]": "<dt id=\"term-Object-files\">Object files</dt><dd><p>The file produced by a compiler - the result of compiling a source file</p></dd>", "a[href=\"#term-Default-Constructor\"]": "<dt id=\"term-Default-Constructor\">Default-Constructor</dt><dd><p>Constructor that is automatically invoked when an object of a class is created without any  arguments - used to construct an object when no user initialisation is provided, using default values instead.</p></dd>", "a[href=\"#term-Regular-Expression\"]": "<dt id=\"term-Regular-Expression\">Regular Expression</dt><dd><p>Regular expressions are used for pattern matching within strings. They are part of the <code class=\"docutils literal notranslate\"><span class=\"pre\">&lt;regex&gt;</span></code> library that provides tools to define, search, and manipulate patterns in text.</p></dd>", "a[href=\"#term-Syntax\"]": "<dt id=\"term-Syntax\">Syntax</dt><dd><p>The set of grammatical rules specifying how the text of a program must be composed. For example, specifying the form of a declaration or the form of a for-statement.</p></dd>", "a[href=\"#term-Programming-Paradigms\"]": "<dt id=\"term-Programming-Paradigms\">Programming Paradigms</dt><dd><p>Different approaches to writing computer programmes. The most common paradigms are: Procedural, Functional, and Object-oriented programming.</p></dd>", "a[href=\"#term-Operator\"]": "<dt id=\"term-Operator\">Operator</dt><dd><p>Symbol used to denote an arithmetic, or logical operation/computation on one or more values or variables, and to instruct the program to perform that operation. Used as part of an expression.</p></dd>", "a[href=\"#term-Core-Language\"]": "<dt id=\"term-Core-Language\">Core Language</dt><dd><p>The fundamental components of the C++ language not found in the Standard Library, whose  libraries are constructed from the core language.</p></dd>", "a[href=\"#term-ASCII\"]": "<dt id=\"term-ASCII\">ASCII</dt><dd><p>American Standard Code for Information Interchange - a character encoding standard that represents text in computers and other devices. ASCII uses 7 bits to encode 128 characters.</p></dd>", "a[href=\"#term-Declarations\"]": "<dt id=\"term-Declarations\">Declarations</dt><dd><p>Declarations introduce names/identifiers into a C++ program. Each kind of entity is declared differently.</p></dd>", "a[href=\"#term-Operands\"]": "<dt id=\"term-Operands\">Operands</dt><dd><p>Literals or variables operated on by operators in an expression.</p></dd>", "a[href=\"#term-Definition\"]": "<dt id=\"term-Definition\">Definition</dt><dd><p>Definitions are declarations that are sufficient to use the entity identified by the name.</p></dd>", "a[href=\"#term-Passing-by-Reference\"]": "<dt id=\"term-Passing-by-Reference\">Passing by Reference</dt><dd><p>If a function parameter type is declared to be a reference to a type, then a reference to a variable can be passed instead of the variable itself. This saves the memory overhead needed to create the local copy of the passed in value and allows the function to operate on the original value instead. Also called call-by-reference, as opposed to call-by-value when the actual value is passed in.</p></dd>", "a[href=\"#term-Object\"]": "<dt id=\"term-Object\">Object</dt><dd></dd>", "a[href=\"#term-Arguments\"]": "<dt id=\"term-Arguments\">Arguments</dt><dd><p>Values passed to a function or template. For templates, the arguments are usually types.</p></dd>", "a[href=\"#term-Functional-Programming\"]": "<dt id=\"term-Functional-Programming\">Functional Programming</dt><dd><p>Programming paradigm that constructs programmes using functions. A declarative model of programming emphasising \u201cwhat to do\u201d rather than \u201chow to do it.\u201d</p></dd>", "a[href=\"#term-Pass-by-Value\"]": "<dt id=\"term-Pass-by-Value\">Pass-by-Value</dt><dd><p>Passing a variable name into a function, which results in a local copy of the variable being created for the used of the function, preserving the original.</p></dd>", "a[href=\"#term-Unary\"]": "<dt id=\"term-Unary\">Unary</dt><dd><p>Describing an operator that operates on a single operand, such as the negation operator. Unary operators are further classified as prefix and postfix. The alternative is an <a class=\"reference internal\" href=\"#term-Infix-Operator\"><span class=\"xref std std-term\">infix operator</span></a>.</p></dd>", "a[href=\"#term-Entity\"]": "<dt id=\"term-Entity\">Entity</dt><dd><p>The entities of a C++ program are values, objects, references, functions, enumerators, types, class members, templates, template specializations, and namespaces.</p></dd>", "a[href=\"#term-Standard-Library\"]": "<dt id=\"term-Standard-Library\">Standard Library</dt><dd><p>Collection of facilities (classes and functions) available for inclusion into C++ programmes \u2013 separated into namespaces.</p></dd>", "a[href=\"#term-Object-file\"]": "<dt id=\"term-Object-file\">Object file</dt><dd><p>The file produced by a compiler - the result of compiling a source file.</p></dd>", "a[href=\"#term-Structured-Binding\"]": "<dt id=\"term-Structured-Binding\">Structured Binding</dt><dd><p>Structured bindings allow you to decompose structured objects like tuples, arrays, or maps into individual variables for cleaner and more readable code.</p></dd>", "a[href=\"#term-Floating-Point-Number-Types\"]": "<dt id=\"term-Floating-Point-Number-Types\">Floating-Point Number Types</dt><dd><p>Float, Double, and Long Double. Floating-point literals are interpreted as <code class=\"docutils literal notranslate\"><span class=\"pre\">double</span></code> type unless the letter \u2018f\u2019 or \u2018l\u2019 is added as a suffix.</p></dd>", "a[href=\"#term-Static-Memory\"]": "<dt id=\"term-Static-Memory\">Static Memory</dt><dd><p>Memory allocated by the <a class=\"reference internal\" href=\"#term-Linker\"><span class=\"xref std std-term\">linker</span></a></p></dd>", "a[href=\"#term-Macro\"]": "<dt id=\"term-Macro\">Macro</dt><dd><p>A <strong>macro</strong> is a fragment of code which has been given a name. Whenever the name is used, it is replaced by the contents of the macro. There are two kinds of macros. They differ mostly in what they look like when they are used. Object-like macros resemble data objects when used, function-like macros resemble function calls.</p></dd>", "a[href=\"#term-Scope-Resolution-Operator\"]": "<dt id=\"term-Scope-Resolution-Operator\">Scope Resolution Operator</dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">::</span></code> - links an entity to its container; like a folder reference. The container defines the scope of the entity.</p></dd>", "a[href=\"#term-Type\"]": "<dt id=\"term-Type\">Type</dt><dd><p>A type defines the proper use of a name or an expression.</p></dd>", "a[href=\"#term-Function-type\"]": "<dt id=\"term-Function-type\">Function-type</dt><dd><p>Combination of the return type and arguments\u2019 type. e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">int(double,</span> <span class=\"pre\">string,</span> <span class=\"pre\">int)</span></code>.</p></dd>", "a[href=\"#term-POD-Type\"]": "<dt id=\"term-POD-Type\">POD Type </dt><dd><p>POD = \u201cPlain Old Data\u201d. A class or a struct that do not include any constructor, destructor or virtual functions - they only have int, char, double, bool, etc. as data members.</p></dd>", "a[href=\"#term-Iteration-Statement\"]": "<dt id=\"term-Iteration-Statement\">Iteration Statement</dt><dd><p>Iterations statements include the <code class=\"docutils literal notranslate\"><span class=\"pre\">for</span></code>-statement, the <code class=\"docutils literal notranslate\"><span class=\"pre\">while</span></code>-statement and the <code class=\"docutils literal notranslate\"><span class=\"pre\">do</span></code>-statement; used to repeat the execution of a block of code until a condition is met or changes.</p></dd>", "a[href=\"#term-Literal\"]": "<dt id=\"term-Literal\">Literal</dt><dd><p>A fixed value written directly into a program. e.g. the number \u20181\u2019, generally found on the RHS of assignment operations. The notation used for Boolean types, character types, string types, numeric types etc., e.g. the word <code class=\"docutils literal notranslate\"><span class=\"pre\">true</span></code> is a Boolean literal when used appropriately.</p></dd>", "a[href=\"#term-Fundamental-Types\"]": "<dt id=\"term-Fundamental-Types\">Fundamental Types</dt><dd><p>Types provide by the <a class=\"reference internal\" href=\"#term-Core-Language\"><span class=\"xref std std-term\">core language</span></a>.</p></dd>", "a[href=\"#term-Flow-Control\"]": "<dt id=\"term-Flow-Control\">Flow Control</dt><dd><p>Control of the sequential flow of execution.</p></dd>", "a[href=\"#term-Heap\"]": "<dt id=\"term-Heap\">Heap</dt><dd><p>The heap is a region of memory used for dynamic memory allocation. Unlike the stack, the heap is managed manually by the programr or automatically by a garbage collector.</p></dd>", "a[href=\"#term-Function-Prototype\"]": "<dt id=\"term-Function-Prototype\">Function Prototype</dt><dd><p>Function Declaration</p></dd>", "a[href=\"#term-Move-assignment\"]": "<dt id=\"term-Move-assignment\">Move-assignment</dt><dd><p>Replaces the contents of the LHS object a with the contents of RHS object, avoiding copying if possible (RHS may be modified). For non-class types, copy and move assignment are indistinguishable and are referred to as direct assignment.</p></dd>", "a[href=\"#term-Overloading\"]": "<dt id=\"term-Overloading\">Overloading</dt><dd><p>Adding multiple definitions to a single operator (or function name). The different definitions apply to different types. For functions the type-pattern of its parameters must be unique.</p></dd>", "a[href=\"#term-Type-Checking\"]": "<dt id=\"term-Type-Checking\">Type Checking</dt><dd><p>The compiler checks every expression to ensure all objects are used correctly in accordance with their type.</p></dd>", "a[href=\"#term-int\"]": "<dt id=\"term-int\">int</dt><dd><p>Keyword for the integer arithmetic data type in C++.</p></dd>", "a[href=\"#term-Expression\"]": "<dt id=\"term-Expression\">Expression</dt><dd><p>A combination of literals or variables with operators that produce a value or may designate objects or functions. Simplest example would be an arithmetic expression e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">a</span> <span class=\"pre\">+</span> <span class=\"pre\">b</span></code>.</p></dd>", "a[href=\"#term-Value-Categories\"]": "<dt id=\"term-Value-Categories\">Value Categories</dt><dd><p>Each C++ expression (an operator with its operands, literals, variables, etc.) is characterized by two independent properties: a type and a <a class=\"reference external\" href=\"https://en.cppreference.com/w/cpp/language/value_category.html\">value category</a>. The include lvalues and rvalues.</p></dd>", "a[href=\"#term-Infix-Operator\"]": "<dt id=\"term-Infix-Operator\">Infix Operator</dt><dd><p>Operator that sits between two variables, denoting an operation using both variable (the operands). As opposed to unary, prefix and postfix, operators that act on one variable positioned before or after it respectively.</p></dd>", "a[href=\"#term-Pointer\"]": "<dt id=\"term-Pointer\">Pointer</dt><dd><p>A named object (variable) that stores the memory address of another object.</p></dd>", "a[href=\"#term-Comma-Operator\"]": "<dt id=\"term-Comma-Operator\">Comma Operator</dt><dd><p>The comma operator allows multiple expressions to be evaluated sequentially, returning the value of the last expression. Used when a single expression is required but it is desirable to perform multiple operations at that point in the code.</p></dd>", "a[href=\"#term-Camel-Case\"]": "<dt id=\"term-Camel-Case\">Camel Case</dt><dd><p><a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Camel_case\">Camel Case</a> is one of the naming conventions used to improve the readability of code, whilst avoiding the use of the \u2018underscore\u2019 character.</p></dd>", "a[href=\"#term-Modulo\"]": "<dt id=\"term-Modulo\">Modulo</dt><dd><p>The <a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Modulo\">modulo</a> operation returns the remainder after dividing the LHS number by the RHS number. In C++ this operation only applies to <code class=\"docutils literal notranslate\"><span class=\"pre\">int</span></code> type and is truncating, meaning the quotient, whether positive or negative, is rounded towards zero before the remainder is determined. Other languages used \u2018floored\u2019 or \u2018rounded\u2019, and for every new language you will need to determine which is applied, because different results are produced.</p></dd>", "a[href=\"#term-Dynamic-Memory\"]": "<dt id=\"term-Dynamic-Memory\">Dynamic Memory</dt><dd><p>Memory that is allocated during runtime using <code class=\"docutils literal notranslate\"><span class=\"pre\">new</span></code>; and deallocated using <code class=\"docutils literal notranslate\"><span class=\"pre\">delete</span></code>. A computer\u2019s RAM must be large enough to accommodate all the objects created during run-time.</p></dd>", "a[href=\"#term-Escape-Sequence\"]": "<dt id=\"term-Escape-Sequence\">Escape Sequence</dt><dd><p>Used in programming languages to represent special characters within a string or character literal. They are identified by the prefix backslash <code class=\"docutils literal notranslate\"><span class=\"pre\">\\</span></code>. Examples are <code class=\"docutils literal notranslate\"><span class=\"pre\">\\n</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">\\t</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">\\\\</span></code> to represent \u2018newline\u2019, \u2018tab\u2019 - and to identify that a backslash is simply a backslash literal.</p></dd>", "a[href=\"#term-Compound-Statement\"]": "<dt id=\"term-Compound-Statement\">Compound Statement</dt><dd><p>Sequence of <a class=\"reference internal\" href=\"#term-Statements\"><span class=\"xref std std-term\">statements</span></a> enclosed by curly braces <code class=\"docutils literal notranslate\"><span class=\"pre\">{}</span></code>. Also called a <a class=\"reference internal\" href=\"#term-Code-Block\"><span class=\"xref std std-term\">code-block</span></a>.</p></dd>", "a[href=\"#term-Iteration-Statements\"]": "<dt id=\"term-Iteration-Statements\">Iteration Statements</dt><dd><p>Iterations statements include the <code class=\"docutils literal notranslate\"><span class=\"pre\">for</span></code>-statement, the <code class=\"docutils literal notranslate\"><span class=\"pre\">while</span></code>-statement and the <code class=\"docutils literal notranslate\"><span class=\"pre\">do</span></code>-statement; used to repeat the execution of a block of code until a condition is met or changes.</p></dd>", "a[href=\"#term-Header-File\"]": "<dt id=\"term-Header-File\">Header File</dt><dd><p>Header files in C++ are essential for organizing and managing code in large projects. They contain declarations of functions, classes, variables, and other identifiers, that inform the compiler about the existence and type of these elements without providing their actual implementation. This separation allows multiple source files to share the same declarations, ensuring consistency and reducing errors, and include them wherever needed, reducing redundancy and improving code maintainability.</p></dd>", "a[href=\"#term-Passing-by-Constant-Reference\"]": "<dt id=\"term-Passing-by-Constant-Reference\">Passing by Constant Reference</dt><dd><p>Passing by reference by declaring the function parameter <code class=\"docutils literal notranslate\"><span class=\"pre\">const</span></code> to prevent modification of the variable by the function\u2019s execution.</p></dd>", "a[href=\"#term-Literals\"]": "<dt id=\"term-Literals\">Literals</dt><dd><p>Literals are the tokens of a C++ program that represent constant values embedded in the source code.</p></dd>", "a[href=\"#term-Char-Type\"]": "<dt id=\"term-Char-Type\">Char Type</dt><dd><p>Type for representing individual characters. Character literals are enclosed by <code class=\"docutils literal notranslate\"><span class=\"pre\">'</span> <span class=\"pre\">'</span></code>. <code class=\"docutils literal notranslate\"><span class=\"pre\">char</span></code>is an integer type - each character has an associated integer value.</p></dd>", "a[href=\"#term-Floating-Point-Number\"]": "<dt id=\"term-Floating-Point-Number\">Floating-Point Number</dt><dd><p>Number with a decimal point. Represented in code by the addition of <code class=\"docutils literal notranslate\"><span class=\"pre\">.0</span></code> to whole numbers.</p></dd>", "a[href=\"#term-Extraction-Operator\"]": "<dt id=\"term-Extraction-Operator\">Extraction Operator</dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">&gt;&gt;</span></code></p></dd>", "a[href=\"#term-Insertion-Operator\"]": "<dt id=\"term-Insertion-Operator\">Insertion Operator</dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">&gt;&gt;</span></code> - used with input streams to assign data to variables.</p></dd>", "a[href=\"#term-Value-Category\"]": "<dt id=\"term-Value-Category\">Value Category</dt><dd><p>Each C++ expression (an operator with its operands, literals, variables, etc.) is characterized by two independent properties: a type and a <a class=\"reference external\" href=\"https://en.cppreference.com/w/cpp/language/value_category.html\">value category</a>. The include lvalues and rvalues.</p></dd>", "a[href=\"#term-rvalue\"]": "<dt id=\"term-rvalue\">rvalue</dt><dd><p>The expression appearing on the right-hand side of an assignment operator or in the {} for list initialisation. rvalues are not always on the RHS, but if the same expression could be used on RHS, it\u2019s probably an rvalue. rvalue expressions including literals, function calls, arithmetic and logical evaluations and comparisons, whose evaluation computes the value of an operand of a built-in operator (no result object) or initializes an object (a result object is created). The result object may be a variable, an object created by new-expression, or a temporary created by temporary materialization. An rvalue expression is either prvalue or xvalue \u2013 see the cppreference for details.</p></dd>", "a[href=\"#term-Copy-Assignment\"]": "<dt id=\"term-Copy-Assignment\">Copy-Assignment</dt><dd><p>Replacement of the contents of one object with the contents of a second object; the second object is unaffected by the operation. Can also initialise an object.</p></dd>", "a[href=\"#term-Type-System\"]": "<dt id=\"term-Type-System\">Type System</dt><dd><p>The set of rules prescribing how each object may be used according to their types.</p></dd>", "a[href=\"#term-Case-Sensitive\"]": "<dt id=\"term-Case-Sensitive\">Case Sensitive</dt><dd><p>Upper and lower case letters are interpreted as different symbols and different values. If a keyword is all lower case, you MUST use all lower case. The name <code class=\"docutils literal notranslate\"><span class=\"pre\">myFunction</span></code> is distinct from the name <code class=\"docutils literal notranslate\"><span class=\"pre\">myfunction</span></code>. Adopting a strict convention for naming, such as <a class=\"reference internal\" href=\"#term-Camel-Case\"><span class=\"xref std std-term\">camel case</span></a> makes it easier to avoid this mistake.</p></dd>", "a[href=\"#term-Functions\"]": "<dt id=\"term-Functions\">Functions</dt><dd><p>A named sequence of statements that can be invoked/called by a program, optionally using arguments supplied by the function call, to optionally return a value to the program. The type of the function includes the comma-separated list of the types of its argument and the type of the value returned. Functions are useful because they are reusable, making code more efficient to write and execute. Functions can be identified by a name with <code class=\"docutils literal notranslate\"><span class=\"pre\">()</span></code>attached.</p></dd>", "a[href=\"#term-Narrowing\"]": "<dt id=\"term-Narrowing\">Narrowing</dt><dd><p>A narrowing (conversion) occurs when a value is converted from one type to another and the new type is not big enough to represent all possible values of the original type - leading to data loss or undefined behaviours.</p></dd>", "a[href=\"#term-Concatenation\"]": "<dt id=\"term-Concatenation\">Concatenation</dt><dd><p>Joining of two strings together. Accomplished by the concatenation operator <code class=\"docutils literal notranslate\"><span class=\"pre\">+</span></code>or a built-in function.</p></dd>", "a[href=\"#term-Linkage\"]": "<dt id=\"term-Linkage\">Linkage</dt><dd><p>linkage refers to how names can refer to the same entities across different scopes or translation units. Internal Linkage - Identifiers can only be seen within a translation unit. External Linkage - Identifiers can be seen in other translation units. No Linkage - Identifiers can only be seen in the scope where they are defined. Linkage is determined by how identifiers are declared, and it affects how names can refer to the same object, function, or other entity throughout the program.\nSometimes used in connection with the linker.</p></dd>", "a[href=\"#term-Standard-Library-Facility\"]": "<dt id=\"term-Standard-Library-Facility\">Standard Library Facility</dt><dd><p>The individual components of the Standard Library made available using the <code class=\"docutils literal notranslate\"><span class=\"pre\">#include</span> <span class=\"pre\">&lt;&gt;</span></code> directive.</p></dd>", "a[href=\"#term-Statements\"]": "<dt id=\"term-Statements\">Statements</dt><dd><p>Statements are fragments of the C++ program that are executed in sequence, or that are used to control the execution flow. The body of any function is a sequence of statements, which may include declaration statements, <a class=\"reference internal\" href=\"#term-Expression-Statements\"><span class=\"xref std std-term\">expression statements</span></a>, and return statements. Other statements include if-statements, while-statements, do-statements, and switch-statements. Simple statements end with a semicolon, but iteration and selection statements are often terminated by <code class=\"docutils literal notranslate\"><span class=\"pre\">}</span></code> ended their code block.</p></dd>", "a[href=\"#term-Compiled-Language\"]": "<dt id=\"term-Compiled-Language\">Compiled Language</dt><dd><p>Programming languages that are converted directly into machine code, creating programmes that can be executed by the computer processor. The alternative is an \u2018interpreted language\u2019, where the source code is interpreted a line at a time by the interpreter at run time \u2013 these programmes run inside larger programmes written in a compiled language including C, JAVA, and C++.</p></dd>", "a[href=\"#term-Default-Value\"]": "<dt id=\"term-Default-Value\">Default Value</dt><dd><p>Value assigned when no other values are assigned. Often used to make an initialisation safe.</p></dd>", "a[href=\"#term-Function-Body\"]": "<dt id=\"term-Function-Body\">Function-Body</dt><dd><p>Sequence of statements to be executed when the function is called.</p></dd>", "a[href=\"#term-Class\"]": "<dt id=\"term-Class\">Class</dt><dd><p>A user-defined data type - a blueprint for creating objects, encapsulating data (attributes) and functions (methods).</p></dd>", "a[href=\"#term-Expression-Statement\"]": "<dt id=\"term-Expression-Statement\">Expression Statement</dt><dd><p>An expression followed by a semicolon.</p></dd>", "a[href=\"#term-Static\"]": "<dt id=\"term-Static\">Static</dt><dd><p>Keyword</p></dd>", "a[href=\"#term-Tuple\"]": "<dt id=\"term-Tuple\">Tuple</dt><dd><p>A container that allows grouping of multiple values of potentially different types into a single object.</p></dd>", "a[href=\"#term-Modulo-Operator\"]": "<dt id=\"term-Modulo-Operator\">Modulo Operator</dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">%</span></code> - the infix operator for modulo operations that returns the remainder after dividing the LHS number by the RHS number. In C++ this operation only applies to <code class=\"docutils literal notranslate\"><span class=\"pre\">int</span></code> type and is truncating, meaning the quotient, whether positive or negative, is rounded towards before the remainder is determined. Other languages used \u2018floored\u2019 or \u2018rounded\u2019, and for every new language you will need to determine which is applied, because different results are produced.</p></dd>", "a[href=\"#term-char\"]": "<dt id=\"term-char\">char</dt><dd><p>Type for representing individual characters. Character literals are enclosed by <code class=\"docutils literal notranslate\"><span class=\"pre\">'</span> <span class=\"pre\">'</span></code>. <code class=\"docutils literal notranslate\"><span class=\"pre\">char</span></code>is an integer type - each character has an associated integer value.</p></dd>", "a[href=\"#term-Assignment-Operator\"]": "<dt id=\"term-Assignment-Operator\">Assignment Operator</dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">=</span></code>. The simple assignment operator. Used to assign a value to a variable, by <a class=\"reference internal\" href=\"#term-Literal-assignment\"><span class=\"xref std std-term\">literal-assignment</span></a>, <a class=\"reference internal\" href=\"#term-Copy-Assignment\"><span class=\"xref std std-term\">copy-assignment</span></a>, or evaluation assignment, and for <a class=\"reference internal\" href=\"#term-Initialisation\"><span class=\"xref std std-term\">initialisation</span></a>. [compound-assignment operators](assignment operators).</p></dd>", "a[href=\"#term-Default-Initialised\"]": "<dt id=\"term-Default-Initialised\">Default-Initialised</dt><dd><p>Type of initialisation that occurs when there is no initialiser. Actual method of default-initialisation depends on the entity.</p></dd>", "a[href=\"#term-Linker\"]": "<dt id=\"term-Linker\">Linker</dt><dd><p>The part of the C++ implementation that merges the code generated from separately compiled translation units into a program, or part of a program</p></dd>", "a[href=\"#term-Immutable\"]": "<dt id=\"term-Immutable\">Immutable</dt><dd><p>Fixed, constant, not permitted to change after initialisation.</p></dd>", "a[href=\"#term-2\"]": "<dt id=\"term-2\">Function-Declaration</dt><dd><p>Statement of the name, types of any arguments, and the return type of a function.</p></dd>", "a[href=\"#term-Switch-Statement\"]": "<dt id=\"term-Switch-Statement\">Switch Statement</dt><dd><p>A selection control structure. Executes one of several possible code-blocks by checking an expression against a list of possible cases. Hierarchical, like an <code class=\"docutils literal notranslate\"><span class=\"pre\">if-else-if</span></code> ladder, the lower cases are only checked if higher cases do not match. Default code-block optionally executed if no cases match.</p></dd>", "a[href=\"#term-Buffer\"]": "<dt id=\"term-Buffer\">Buffer</dt><dd><p>A memory space used for temporarily storing data before processing (e.g. assigning to a variable), or writing to a file. Buffers are necessary because of the vast differences in speed between data producers and consumers.</p></dd>", "a[href=\"#term-Scope\"]": "<dt id=\"term-Scope\">Scope</dt><dd><p>The context in which a variable, function, or class is defined. May be global, namespace, class, function, block/local.</p></dd>", "a[href=\"#term-Statement\"]": "<dt id=\"term-Statement\">Statement</dt><dd><p>Statements are fragments of the C++ program that are executed in sequence, or that are used to control the execution flow. The body of any function is a sequence of statements, which may include declaration statements, <a class=\"reference internal\" href=\"#term-Expression-Statements\"><span class=\"xref std std-term\">expression statements</span></a>, and return statements. Other statements include if-statements, while-statements, do-statements, and switch-statements. Simple statements end with a semicolon, but iteration and selection statements are often terminated by <code class=\"docutils literal notranslate\"><span class=\"pre\">}</span></code> ended their code block.</p></dd>", "a[href=\"#term-Void\"]": "<dt id=\"term-Void\">Void</dt><dd><p>Used to declare that a function returns nothing. Cannot be used to declare a variable as having no type. Used to declare that a pointer is of universal type i.e. void* pointer to a name that\u2019s type is not defined yet.</p></dd>", "a[href=\"#term-Assignment\"]": "<dt id=\"term-Assignment\">Assignment</dt><dd><p>Modification of the current value of an object using an assignment operator. Simplest case is using the simple assignment operator <code class=\"docutils literal notranslate\"><span class=\"pre\">=</span></code>; i.e. <code class=\"docutils literal notranslate\"><span class=\"pre\">LHS</span> <span class=\"pre\">=</span> <span class=\"pre\">RHS;</span></code>.</p></dd>", "a[href=\"#term-Control-Flow\"]": "<dt id=\"term-Control-Flow\">Control Flow</dt><dd><p>The sequential flow of <em><strong>control</strong></em> through the program - the program\u2019s statement that is being executed at each instant is said to have <strong>control</strong> of the processor. The order in which individual statements, instructions, or function calls of an imperative program are executed, or evaluated.</p></dd>", "a[href=\"#term-Comments\"]": "<dt id=\"term-Comments\">Comments</dt><dd><p>Comments are plain text in a computer program that are only intended as a note to the programr. Comments are useful as in-code documentation and are also used by programrs to hide sections of a program from the compiler temporarily - useful during development/debugging.</p></dd>", "a[href=\"#term-List-Initialisation\"]": "<dt id=\"term-List-Initialisation\">List-Initialisation</dt><dd><p>Initialization using <code class=\"docutils literal notranslate\"><span class=\"pre\">{}</span></code> e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">int</span> <span class=\"pre\">myInt</span> <span class=\"pre\">{initial</span> <span class=\"pre\">value</span> <span class=\"pre\">or</span> <span class=\"pre\">expression</span> <span class=\"pre\">to</span> <span class=\"pre\">produce</span> <span class=\"pre\">the</span> <span class=\"pre\">initial</span> <span class=\"pre\">value};</span></code></p></dd>", "a[href=\"#term-Memory\"]": "<dt id=\"term-Memory\">Memory</dt><dd><p>Computer memory stores information, such as data and programmes, for immediate use in the computer. The term memory is often synonymous with RAM (Random Access Memory), or primary storage.</p></dd>", "a[href=\"#term-Instruction-Set-Architecture\"]": "<dt id=\"term-Instruction-Set-Architecture\">Instruction Set Architecture</dt><dd><p>Specifies the format of machine code used by the programmable interface of a <a class=\"reference internal\" href=\"#term-CPU\"><span class=\"xref std std-term\">CPU</span></a>. The \u2018instructions\u2019 are patterns of bits, each of which is unique to a specific task.</p></dd>", "a[href=\"#term-Initialisation\"]": "<dt id=\"term-Initialisation\">Initialisation</dt><dd><p>Setting the initial value of an object. Definition results when initialisation is added to a declaration. Initialization is different from assignment because the object had no previous value and initialization is done by <a class=\"reference internal\" href=\"#term-Constructors\"><span class=\"xref std std-term\">constructors</span></a>.</p></dd>", "a[href=\"#term-Value\"]": "<dt id=\"term-Value\">Value</dt><dd><p>The literal stored in a variable. Other usages - see <a class=\"reference internal\" href=\"#term-Value-Categories\"><span class=\"xref std std-term\">Value Categories</span></a>.</p></dd>", "a[href=\"#term-Declarator\"]": "<dt id=\"term-Declarator\">Declarator</dt><dd><p>The part of a declaration that specifies the name of an entity - may include modifiers.</p></dd>", "a[href=\"#term-Operators\"]": "<dt id=\"term-Operators\">Operators</dt><dd><p>Symbols used to denote an arithmetic, or logical operation/computation on one or more values or variables, and to instruct the program to perform that operation. Used as part of an expression.</p></dd>", "a[href=\"#term-Macros\"]": "<dt id=\"term-Macros\">Macros</dt><dd><p>Macros are preprocessor directives used for code substitution. A macro is a fragment of code which has been given a name. Whenever the name is used, it is replaced by the contents of the macro. There are two kinds of macros. They differ mostly in what they look like when they are used. Object-like macros resemble data objects when used, function-like macros resemble function calls.</p></dd>", "a[href=\"#term-Programming-Paradigm\"]": "<dt id=\"term-Programming-Paradigm\">Programming Paradigm</dt><dd><p>Model of how to structure and implement computer programmes.</p></dd>", "a[href=\"#term-References\"]": "<dt id=\"term-References\">References</dt><dd><p>The memory address of an object.</p></dd>", "a[href=\"#term-Standard-Library-Facilities\"]": "<dt id=\"term-Standard-Library-Facilities\">Standard Library Facilities</dt><dd><p>The individual components of the Standard Library made available using the <code class=\"docutils literal notranslate\"><span class=\"pre\">#include</span> <span class=\"pre\">&lt;&gt;</span></code> directive.</p></dd>", "a[href=\"#term-Copy-initialisation\"]": "<dt id=\"term-Copy-initialisation\">Copy-initialisation</dt><dd><p>Initialising an object from another object using the assignment operator.</p></dd>", "a[href=\"#term-Memory-Address\"]": "<dt id=\"term-Memory-Address\">Memory Address</dt><dd><p>A computer memory address is a unique identifier assigned to a specific location in a computer\u2019s memory, allowing the CPU and other hardware components to access and manipulate stored data efficiently. Memory addresses are typically represented as an array of hexadecimal values of a fixed length.</p></dd>", "a[href=\"#term-String\"]": "<dt id=\"term-String\">String</dt><dd><p>Sequence of characters collected into a single variable - a <code class=\"docutils literal notranslate\"><span class=\"pre\">char</span></code> array - denoted by a literal enclosed in double quote marks <code class=\"docutils literal notranslate\"><span class=\"pre\">\"\"</span></code>. <code class=\"docutils literal notranslate\"><span class=\"pre\">std::string</span></code> provides a methods for manipulating strings. <code class=\"docutils literal notranslate\"><span class=\"pre\">std::string</span></code> behaves like a containter but is not part of the C++ <container> library.</container></p></dd>", "a[href=\"#term-Function-Arguments\"]": "<dt id=\"term-Function-Arguments\">Function-Arguments</dt><dd><p>The values passed into a function. The function declaration specifies the number and type of the required arguments, which must be matched by each call to that function.</p></dd>", "a[href=\"#term-Falling-Through\"]": "<dt id=\"term-Falling-Through\">Falling Through</dt><dd><p>When a program reaches the end of code-block and just continues onto the next statements. Causes an error for a function if a return is expected but permitted for <code class=\"docutils literal notranslate\"><span class=\"pre\">void</span></code>.</p></dd>", "a[href=\"#term-Extraction\"]": "<dt id=\"term-Extraction\">Extraction</dt><dd><p>Transfer of data out of a stream into a variable.</p></dd>", "a[href=\"#term-Declarator-operator\"]": "<dt id=\"term-Declarator-operator\">Declarator-operator</dt><dd><p>Operators used to modify the type of a variable, function, or object being declared. e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">*</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">&amp;</span></code> for pointers, and <code class=\"docutils literal notranslate\"><span class=\"pre\">[]</span></code> for arrays.</p></dd>", "a[href=\"#term-Function-Definition\"]": "<dt id=\"term-Function-Definition\">Function-Definition</dt><dd><p>Function declaration that includes the <a class=\"reference internal\" href=\"#term-Function-Body\"><span class=\"xref std std-term\">function-body</span></a>.</p></dd>", "a[href=\"#term-CPU\"]": "<dt id=\"term-CPU\">CPU</dt><dd><p><a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Central_processing_unit\">Central Processing Unit</a> is the electronic circuitry inside a computer that executes the machine code version of computer programmes.</p></dd>", "a[href=\"#term-Scalar\"]": "<dt id=\"term-Scalar\">Scalar</dt><dd><p>A type that holds a single value of a defined range. Scalars include arithmetic types (integral or floating-point values), enumeration type members, pointer types, pointer-to-member types, and <code class=\"docutils literal notranslate\"><span class=\"pre\">std::nullptr_t</span></code>. Fundamental types are typically scalar types.</p></dd>", "a[href=\"#term-Function-Parameter\"]": "<dt id=\"term-Function-Parameter\">Function-Parameter</dt><dd><p>Placeholders in the function declaration for the arguments that will be passed in. The parameter is the local variable name within the function body associated with the corresponding argument\u2019s value.</p></dd>", "a[href=\"#term-Enumerator\"]": "<dt id=\"term-Enumerator\">Enumerator</dt><dd><p>A name identifying a value of an enumeration.</p></dd>", "a[href=\"#term-Types\"]": "<dt id=\"term-Types\">Types</dt><dd><p>A type defines the proper use of a name or an expression.</p></dd>", "a[href=\"#term-Pass-by-Reference\"]": "<dt id=\"term-Pass-by-Reference\">Pass-by-Reference</dt><dd><p>Passing a reference to a variable as the argument of a function call. Allows the modification of that variable by the function.</p></dd>", "a[href=\"#term-Reference\"]": "<dt id=\"term-Reference\">Reference</dt><dd><p>The memory address of an object.</p></dd>", "a[href=\"#term-Member\"]": "<dt id=\"term-Member\">Member</dt><dd><p>Types, variables and constants, and functions declared within the scope of, and therefore belonging to, a class.</p></dd>", "a[href=\"#term-Directives\"]": "<dt id=\"term-Directives\">Directives</dt><dd><p>Also known as preprocessor directives - instructions that are processed before compilation of the C++ code begins. Directives start with <code class=\"docutils literal notranslate\"><span class=\"pre\">#</span></code> and must lie at the top of the document. Used for including files (<code class=\"docutils literal notranslate\"><span class=\"pre\">#include</span></code>), such as libraries, and defining <a class=\"reference internal\" href=\"#term-Macros\"><span class=\"xref std std-term\">macros</span></a>(<code class=\"docutils literal notranslate\"><span class=\"pre\">#define</span></code>), and conditional compilation (<code class=\"docutils literal notranslate\"><span class=\"pre\">#if</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">#ifdef</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">#ifndef</span></code>).</p></dd>", "a[href=\"#term-Local-Variables\"]": "<dt id=\"term-Local-Variables\">Local Variables</dt><dd><p>Variable declared within the current scope.</p></dd>", "a[href=\"#term-Expression-assignment\"]": "<dt id=\"term-Expression-assignment\">Expression-assignment</dt><dd><p>Replaces the LHS object with the result of the evaluation of the expression stated on RHS.</p></dd>", "a[href=\"https://en.cppreference.com/w/cpp/keywords.html\"]": "<p>Keywords</p>"}
skip_classes = ["headerlink", "sd-stretched-link"]

window.onload = function () {
    for (const [select, tip_html] of Object.entries(selector_to_html)) {
        const links = document.querySelectorAll(` ${select}`);
        for (const link of links) {
            if (skip_classes.some(c => link.classList.contains(c))) {
                continue;
            }

            tippy(link, {
                content: tip_html,
                allowHTML: true,
                arrow: true,
                placement: 'auto-start', maxWidth: 500, interactive: false, theme: 'material', duration: [200, 100], delay: [200, 0],

            });
        };
    };
    console.log("tippy tips loaded!");
};
