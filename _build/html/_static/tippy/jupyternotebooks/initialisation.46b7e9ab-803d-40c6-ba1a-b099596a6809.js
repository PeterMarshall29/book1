selector_to_html = {"a[href=\"#initialiser-lists\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Initialiser Lists<a class=\"headerlink\" href=\"#initialiser-lists\" title=\"Link to this heading\">#</a></h2><p>More complicated\nobjects can require more than one value as an initializer. This is primarily handled by initializer\nLists delimited by { and }. For example:\nint a[] = { 1, 2 }; // array initializer\nstruct S { int x; std::string s; };\nS s = { 1, \u201cHelios\u201d }; // struct initializer\nstd::complex<double> z = { 0, pi }; // use constructor\nstd::vector<double> v = { 0.0, 1.1, 2.2, 3.3 }; // use list constructor</double></double></p><p>In some cases, function-style argument lists can also be used (\u00a72.3, \u00a716.2.5). For example:\nstd::complex<double> z(0, std::numbers::pi); // use constructor\nstd::vector<double> v(10, 3.3); // use constructor : v gets 10 elements initialized to 3.3st constructor</double></double></p>", "a[href=\"#auto\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Auto<a class=\"headerlink\" href=\"#auto\" title=\"Link to this heading\">#</a></h2><p>When defining a variable, you don\u2019t actually need to state its type explicitly when it can be deduced from the initializer:\nauto b = true; // a bool\nauto ch = \u2018x\u2019; // a char\nauto i = 123; // an int\nauto d = 1.2; // a double\nauto z = sqrt(y); // z has the type of whatever sqrt(y) returns</p><p>Warning Be careful \u2013 best to always specify type and initialise immediately!</p>", "a[href=\"#initialisers\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Initialisers<a class=\"headerlink\" href=\"#initialisers\" title=\"Link to this heading\">#</a></h2><p>If an initializer is specified for an object, that initializer determines the initial value of an object.\nAn initializer can use one of four syntactic styles:\nX a1 {v};\nX a2 = {v};\nX a3 = v;\nX a4(v);\nOf these, only the first can be used in every context\nAnything more complicated than initialising a simple variable is is better done using {}. Initialization using {} is called \u201clist initialization\u201d and does not allow narrowing. That is:</p>", "a[href=\"#initialisation\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Initialisation<a class=\"headerlink\" href=\"#initialisation\" title=\"Link to this heading\">#</a></h1><p>Always initialise your variables \u2013 prevents accidental use before definition.</p><p>Only exception are strings and vectors; which by default have empty conditions initialised, \u201c\u201d for strings, v.capacity() = 0 for vector.</p>", "a[href=\"#missing-inialiser\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">missing inialiser<a class=\"headerlink\" href=\"#missing-inialiser\" title=\"Link to this heading\">#</a></h2><p>If no initializer is specified, a global (\u00a76.3.4), namespace (\u00a714.3.1), local static (\u00a712.1.8), or static member (\u00a716.2.12) (collectively called static objects) is initialized to {} of the appropriate type. For example:\nint a; // means \u2018\u2018int a{};\u2019\u2019 so that a becomes 0\ndouble d; // means \u2018\u2018double d{};\u2019\u2019 so that d becomes 0.0</p><p>Local variables and objects created on the free store (sometimes called dynamic objects or heap objects; \u00a711.2) are not initialized by unless they are of user-defined types with a default constructor (\u00a717.3.3). For example:\nint x; // x does not have a well-defined value\nchar buf[1024]; // buf[i] does not have a well-defined value\nint* p{ new int }; //<em>p does not have a well-defined value\nchar</em> q{ new char[1024] }; // q[i] does not have a well-defined value\nstd::string s; // s==\u201c\u201d because of string\u2019s default constructor\nstd::vector<char> v; // v=={} because of vector\u2019s default constructor\nstd::string* ps{ new std::string }; // *ps is \u201c\u201d because of string\u2019s default constructor\nIf you want initialization of local variables of built-in type or objects of built-in type created with new, use {}.</char></p>", "a[href=\"#empty-initialiser\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Empty initialiser<a class=\"headerlink\" href=\"#empty-initialiser\" title=\"Link to this heading\">#</a></h2><p>Empty Initialiser List {} is used to indicate that a default value is desired. For example:\nint x4{}; // x4 becomes 0\ndouble d4{}; // d4 becomes 0.0\nchar* p{}; //p becomes nullptr\nstd::vector<int> v4{}; // v4 becomes the empty vector\nstd::string s4{}; // s4 becomes \u201c\u201d\nMost types have a default value. For integral types, the default value is a suitable representation of\nzero. For pointers, the default value is nullptr .\nFor user-defined types, the default value (if any) is determined by the type\u2019s constructors.\nFor user-defined types, there can be a distinction between direct initialization (where implicit conversions are allowed) and copy initialization (where they are not).</int></p>"}
skip_classes = ["headerlink", "sd-stretched-link"]

window.onload = function () {
    for (const [select, tip_html] of Object.entries(selector_to_html)) {
        const links = document.querySelectorAll(` ${select}`);
        for (const link of links) {
            if (skip_classes.some(c => link.classList.contains(c))) {
                continue;
            }

            tippy(link, {
                content: tip_html,
                allowHTML: true,
                arrow: true,
                placement: 'auto-start', maxWidth: 500, interactive: false,

            });
        };
    };
    console.log("tippy tips loaded!");
};
