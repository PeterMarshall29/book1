selector_to_html = {"a[href=\"#structure-of-declarations\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Structure of Declarations<a class=\"headerlink\" href=\"#structure-of-declarations\" title=\"Link to this heading\">#</a></h2><p>The structure of a declaration is defined by the C++ grammar (\u00a7iso.A). This grammar evolved over four decades, starting with the early C grammars, and is quite complicated. However, without too many radical simplifications, we can consider a declaration as having five parts (in order):\n\u2022 Optional prefix specifiers (e.g., static or virtual)\n\u2022 A base type (e.g., vector<double> or const int)\n\u2022 A declarator optionally including a name (e.g., p[7], n, or \u2217(\u2217)[])\n\u2022 Optional suffix function specifiers (e.g., const or noexcept)\n\u2022 An optional initializer or function body (e.g., ={7,5,3} or {return x;})\nExcept for function and namespace definitions, a declaration is terminated by a semicolon.</double></p>", "a[href=\"#functions\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Functions<a class=\"headerlink\" href=\"#functions\" title=\"Link to this heading\">#</a></h1><p>We define a function when we want a separate computation with a name because doing so:</p>", "a[href=\"#declaration-good-practice\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Declaration Good Practice<a class=\"headerlink\" href=\"#declaration-good-practice\" title=\"Link to this heading\">#</a></h2><p>Before the main() put:</p><p>Constant declarations\nFunction prototype declarations</p>", "a[href=\"#function-call-and-return\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Function Call and Return<a class=\"headerlink\" href=\"#function-call-and-return\" title=\"Link to this heading\">#</a></h2><p>Examples:\ndouble fct(int a, double d) { return a*d; }</p><p>If the function returns nothing label it with void.\nList all values to be passed in \u2013 in the order that they will used in the call.\nNames of parameters in the function declaration are the local names used within the function.</p>", "a[href=\"#declarations\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Declarations<a class=\"headerlink\" href=\"#declarations\" title=\"Link to this heading\">#</a></h2><p>Everything must be declared before it can be used.\nReason: what if you call two functions in each others definition \u2013 one definition must come first \u2013 the solution is declare both \u2013 then it does not matter, which is defined first. And the declaration does not involve the other functions, so no issues there.\n\u00a0\nKinds of declarations\nThere are many kinds of entities that a programmer can define in C++. The most interesting are:\nVariables\nConstants\nFunctions\nNamespaces\nTypes (classes and enumerations)\nTemplates</p><p>The declaration is just an interface \u2013 describes what the definition has to conform to.\nextern int myFunction(int);\nextern keyword means the myFunction declaration is not a definition. It is rarely used.</p>", "a[href=\"#initialisation\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Initialisation<a class=\"headerlink\" href=\"#initialisation\" title=\"Link to this heading\">#</a></h2><p>Always initialise your variables \u2013 prevents accidental use before definition.</p><p>Only exception are strings and vectors; which by default have empty conditions initialised, \u201c\u201d for strings, v.capacity() = 0 for vector.</p>", "a[href=\"#hidden-or-shadowed-names\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Hidden or Shadowed Names<a class=\"headerlink\" href=\"#hidden-or-shadowed-names\" title=\"Link to this heading\">#</a></h2><p>A declaration of a name in a block can hide a declaration in an enclosing block or a global name.\nThat is, a name can be redefined to refer to a different entity within a block. After exit from the block, the name resumes its previous meaning.</p><p>A hidden global name can be referred to using the scope resolution operator, ::. For example:\nint x;\nvoid main()\n{\nint x = 1; // hide global x\n::x = 2; // assign to global x\nx = 3; // assign to local x</p>", "a[href=\"#pass-by-reference\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Pass by Reference<a class=\"headerlink\" href=\"#pass-by-reference\" title=\"Link to this heading\">#</a></h2><p>Pass by reference allows us to modify the original values.\nExample: two ways for a program to modify some named variable\nTo be accessible by a function the variable must be global, which means declaring it before the main function, otherwise the myPrint functions could not alter it, only its copy.\nExample 1 \u2013 altering a global variable.\nstd::vector<double> a = { 5.9,8,1.1,2.3,4.5,5.6 };\nvoid myPrinter(std::vector<double> v)\n{\nstd::cout &lt;&lt; \u201c{\u201d;\nfor (int i = 0; i &lt; v.size(); ++i) {\nstd::cout &lt;&lt; v[i];\nif (i != v.size() - 1) std::cout &lt;&lt; \u201c,\u201d;\n}\nstd::cout &lt;&lt; \u201c}\\n\u201d;\n}</double></double></p><p>void myPrinter2(std::vector<double> v)\n{\nstd::cout &lt;&lt; \u201c{\u201d;\nfor (int i = 0; i &lt; v.size(); ++i) {\na[i] = a[i] + 1;\nstd::cout &lt;&lt; v[i];</double></p>", "a[href=\"#pass-by-constant-reference\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Pass by Constant Reference<a class=\"headerlink\" href=\"#pass-by-constant-reference\" title=\"Link to this heading\">#</a></h2><p>If you are not passing small values, then passing by value is costly because it creates a new local copy \u2013 could be an image with gigabytes. A memory address of a name is called a reference.\nA parameter type that has &amp; attached, indicated that a reference to a name is being passed in.\nConst is used to stop the function altering the name referenced.\nAll programs run faster when function parameters are references not values (i.e. copied).</p><p>void myPrinter(const std::vector<double>&amp; v)\n{\nstd::cout &lt;&lt; \u201c{\u201d;\nfor (int i = 0; i &lt; v.size(); ++i) {\nstd::cout &lt;&lt; v[i];\nif (i != v.size() - 1) std::cout &lt;&lt; \u201c,\u201d;\n}\nstd::cout &lt;&lt; \u201c}\\n\u201d;\n}\nint main() {\nstd::vector<double> a = { 5.9,8,1.1,2.3,4.5,5.6 };\nmyPrinter(a);\t\nreturn 0;\n}</double></double></p>", "a[href=\"#syntax-of-a-function-call\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Syntax of a Function Call<a class=\"headerlink\" href=\"#syntax-of-a-function-call\" title=\"Link to this heading\">#</a></h2><p>Syntax of a function call:  returnType functionIdentifier ( parameter-list ) {function-body}\nThe function identifier is mainly its name \u2013 use camel case \u2013 though used slightly differently the term identifier can include the two types.\nThe list of arguments (values/types) to be passed to the function is put in the parameter list. The parameter list is comma separated \u2013 for each argument put the type then a parameter (variable name that one argument will have inside the function) space separated.\nThe identifier is just the name of the function, though strictly the two types are part of the identifier too.\nThe arguments specified in a function call must be delivered exactly \u2013 type and number matched.\nThe returned value from a function need not be used for anything. Compiler may cite it as an error if unused.\nA function that returns nothing can be declared as void \u2013 better practice.</p><p>Example\nint square(int x) {\nreturn x * x;\n}\nint main()\n{\nfor (int i = 0; i &lt; 100; ++i) {\nstd::cout &lt;&lt; i &lt;&lt; \u201c\\t\u201d &lt;&lt; square(i) &lt;&lt; \u201c\\n\u201d;\n++i;\n}\nreturn 0;\n}</p>", "a[href=\"#declarations-and-definition\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Declarations and Definition<a class=\"headerlink\" href=\"#declarations-and-definition\" title=\"Link to this heading\">#</a></h2><p>A definition requires the code body also. \u2018Declarations are not definitions\u2019.</p><p>int myFunction(int); // is a declaration</p>"}
skip_classes = ["headerlink", "sd-stretched-link"]

window.onload = function () {
    for (const [select, tip_html] of Object.entries(selector_to_html)) {
        const links = document.querySelectorAll(` ${select}`);
        for (const link of links) {
            if (skip_classes.some(c => link.classList.contains(c))) {
                continue;
            }

            tippy(link, {
                content: tip_html,
                allowHTML: true,
                arrow: true,
                placement: 'auto-start', maxWidth: 500, interactive: false,

            });
        };
    };
    console.log("tippy tips loaded!");
};
