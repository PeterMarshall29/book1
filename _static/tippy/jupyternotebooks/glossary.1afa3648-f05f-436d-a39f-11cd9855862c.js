selector_to_html = {"a[href=\"https://en.wikipedia.org/wiki/Binary_code\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/a/af/Binary_to_Hexadecimal_or_Decimal.jpg\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p>A <b>binary code</b> is the value of a data-encoding convention represented in a binary notation that usually is a sequence of 0s and 1s; sometimes called a <i>bit string</i>. For example, ASCII is an 8-bit text encoding that in addition to the human readable form (letters) can be represented as binary. <i>Binary code</i> can also refer to the mass noun <i>code</i> that is not human readable in nature such as machine code and bytecode.</p>", "a[href^=\"https://en.wikipedia.org/wiki/Binary_code#\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/a/af/Binary_to_Hexadecimal_or_Decimal.jpg\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p>A <b>binary code</b> is the value of a data-encoding convention represented in a binary notation that usually is a sequence of 0s and 1s; sometimes called a <i>bit string</i>. For example, ASCII is an 8-bit text encoding that in addition to the human readable form (letters) can be represented as binary. <i>Binary code</i> can also refer to the mass noun <i>code</i> that is not human readable in nature such as machine code and bytecode.</p>", "a[href=\"https://en.wikipedia.org/wiki/Central_processing_unit\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/0/0a/Intel_i9-14900KF_CPU.jpg/330px-Intel_i9-14900KF_CPU.jpg\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p>A <b>central processing unit</b> (<b>CPU</b>), also called a <b>central processor</b>, <b>main processor</b>, or just <b>processor</b>, is the primary processor in a given computer. Its electronic circuitry executes instructions of a computer program, such as arithmetic, logic, controlling, and input/output (I/O) operations. This role contrasts with that of external components, such as main memory and I/O circuitry, and specialized coprocessors such as graphics processing units (GPUs).</p>", "a[href^=\"https://en.wikipedia.org/wiki/Central_processing_unit#\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/0/0a/Intel_i9-14900KF_CPU.jpg/330px-Intel_i9-14900KF_CPU.jpg\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p>A <b>central processing unit</b> (<b>CPU</b>), also called a <b>central processor</b>, <b>main processor</b>, or just <b>processor</b>, is the primary processor in a given computer. Its electronic circuitry executes instructions of a computer program, such as arithmetic, logic, controlling, and input/output (I/O) operations. This role contrasts with that of external components, such as main memory and I/O circuitry, and specialized coprocessors such as graphics processing units (GPUs).</p>", "a[href=\"https://en.wikipedia.org/wiki/Camel_case\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/c/c8/CamelCase_new.svg/330px-CamelCase_new.svg.png\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p>The writing format <b>camel case</b> is the practice of writing phrases without spaces or punctuation and with capitalized words. The format indicates the first word starting with either case, then the following words having an initial uppercase letter. Common examples include <i>YouTube</i>, <i>PowerPoint</i>, <i>HarperCollins</i>, <i>FedEx</i>, <i>iPhone</i>, <i>eBay</i>, and <i>LaGuardia</i>. Camel case is often used as a naming convention in computer programming. It is also sometimes used in online usernames such as <i>JohnSmith</i>, and to make multi-word domain names more legible, for example in promoting <i>EasyWidgetCompany.com</i>.</p>", "a[href^=\"https://en.wikipedia.org/wiki/Camel_case#\"]": "<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/c/c8/CamelCase_new.svg/330px-CamelCase_new.svg.png\" alt=\"Wikipedia thumbnail\" style=\"float:left; margin-right:10px;\"><p>The writing format <b>camel case</b> is the practice of writing phrases without spaces or punctuation and with capitalized words. The format indicates the first word starting with either case, then the following words having an initial uppercase letter. Common examples include <i>YouTube</i>, <i>PowerPoint</i>, <i>HarperCollins</i>, <i>FedEx</i>, <i>iPhone</i>, <i>eBay</i>, and <i>LaGuardia</i>. Camel case is often used as a naming convention in computer programming. It is also sometimes used in online usernames such as <i>JohnSmith</i>, and to make multi-word domain names more legible, for example in promoting <i>EasyWidgetCompany.com</i>.</p>", "a[href=\"#term-Construction\"]": "<dt id=\"term-Construction\">Construction</dt><dd><p>def</p></dd>", "a[href=\"#term-Declaration\"]": "<dt id=\"term-Declaration\">Declaration</dt><dd><p>Declarations introduce names into a C++ program. Each kind of entity is declared differently.</p></dd>", "a[href=\"#term-Iteration\"]": "<dt id=\"term-Iteration\">Iteration</dt><dd><p>Iteration</p></dd>", "a[href=\"#term-Stack\"]": "<dt id=\"term-Stack\">Stack</dt><dd></dd>", "a[href=\"#term-Standard-Library-Facility\"]": "<dt id=\"term-Standard-Library-Facility\">Standard Library Facility</dt><dd><p>The individual components of the Standard Library, made available using the <code class=\"docutils literal notranslate\"><span class=\"pre\">#include</span> <span class=\"pre\">&lt;&gt;</span></code> syntax.</p></dd>", "a[href=\"#term-Null-Character\"]": "<dt id=\"term-Null-Character\">Null Character</dt><dd><p>The null character is a control character represented by escape sequence \u2018\\0\u2019 that has an integer value of 0. May be used to signify the end of a string in C-style strings (character arrays). \u2018\\0\u2019 is a character literal with a value of 0. Can also reprsent the <code class=\"docutils literal notranslate\"><span class=\"pre\">nullptr</span></code> for comparison expressions. The null character is stored as a byte (8 bits) with all bits set to zero.</p></dd>", "a[href=\"#term-Binary\"]": "<dt id=\"term-Binary\">Binary</dt><dd><p><a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Binary_code\">Binary Code</a> is a sequence of 1\u2019s and 0\u2019s. Each one <code class=\"docutils literal notranslate\"><span class=\"pre\">1</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">0</span></code> is called a bit. A computer will read a specific number of bits (e.g. 64) at a time. Differnt sequences are differnt instructions to the CPU.</p></dd>", "a[href=\"#term-Copy-Assignment\"]": "<dt id=\"term-Copy-Assignment\">Copy Assignment</dt><dd><p>Replacement of the contents of one object with the contents of a second object; the second object is unaffected by the operation. Can also intitialise an object.</p></dd>", "a[href=\"#term-Initialiser\"]": "<dt id=\"term-Initialiser\">Initialiser</dt><dd><p>def</p></dd>", "a[href=\"#term-Memory\"]": "<dt id=\"term-Memory\">Memory</dt><dd><p>Definition needed</p></dd>", "a[href=\"#term-Free-store\"]": "<dt id=\"term-Free-store\">Free store</dt><dd><p><a class=\"reference internal\" href=\"#term-Memory\"><span class=\"xref std std-term\">memory</span></a> allocated by <code class=\"docutils literal notranslate\"><span class=\"pre\">new</span></code>; also called dynamic memory. Often standard library facilities, such as <code class=\"docutils literal notranslate\"><span class=\"pre\">vector</span></code>, can be used to avoid explicit use of free store.</p></dd>", "a[href=\"#term-Declarator\"]": "<dt id=\"term-Declarator\">Declarator</dt><dd><p>The part of a declaration that specifies the name of an entity, and may include modifiers</p></dd>", "a[href=\"#term-Function-Definition\"]": "<dt id=\"term-Function-Definition\">Function Definition</dt><dd><p>Function declarartion that include the <a class=\"reference internal\" href=\"#term-Function-Body\"><span class=\"xref std std-term\">function body</span></a>.</p></dd>", "a[href=\"#term-Translation-units\"]": "<dt id=\"term-Translation-units\">Translation units</dt><dd><p>Part of a program that can be separately compiled. Individual source, or header, files.</p></dd>", "a[href=\"#term-Programming-Paradigm\"]": "<dt id=\"term-Programming-Paradigm\">Programming Paradigm</dt><dd><p>Model of how to structure and implement computer programs.</p></dd>", "a[href=\"#term-Objects\"]": "<dt id=\"term-Objects\">Objects</dt><dd></dd>", "a[href=\"#term-Empty-Statement\"]": "<dt id=\"term-Empty-Statement\">Empty Statement</dt><dd><p>A statement that consists of only a semicolon <code class=\"docutils literal notranslate\"><span class=\"pre\">;</span></code>. It does nothing and is often referred to as a <a class=\"reference internal\" href=\"#term-Null-Statement\"><span class=\"xref std std-term\">null statement</span></a>. Empty states are used where the syntax requires a statement but the contents are optionally not required, to provide an empty body to a for or while loop, or to carry a label in the end of a compound statement.</p></dd>", "a[href=\"#term-Const\"]": "<dt id=\"term-Const\">Const</dt><dd><p>Const: A keyword that makes a variable or function parameter immutable.</p></dd>", "a[href=\"#term-Machine-Code\"]": "<dt id=\"term-Machine-Code\">Machine Code</dt><dd><p>Computer programs encoded and structured to run directly on a computers hardware. The different <a class=\"reference internal\" href=\"#term-CPU\"><span class=\"xref std std-term\">CPU</span></a> architectures, x86, ARM, Apple Silicon, have differnt programmable interfaces and require different machine code specified by an <a class=\"reference internal\" href=\"#term-Instruction-Set-Architecture\"><span class=\"xref std std-term\">instruction set architecture</span></a>.</p></dd>", "a[href=\"#term-String-Data-Type\"]": "<dt id=\"term-String-Data-Type\">String Data Type</dt><dd><p>Data consisting of a sequence of characters, bracketed by <code class=\"docutils literal notranslate\"><span class=\"pre\">\"\"</span></code>.</p></dd>", "a[href=\"#term-For-loop\"]": "<dt id=\"term-For-loop\">For-loop</dt><dd><p>Common name for the for-statement.</p></dd>", "a[href=\"#term-Core-Language\"]": "<dt id=\"term-Core-Language\">Core Language</dt><dd><p>def</p></dd>", "a[href=\"#term-Control-Flow\"]": "<dt id=\"term-Control-Flow\">Control Flow</dt><dd><p>The sequential flow of <em><strong>control</strong></em> through the program -  the current statement has <em>control</em> of the processor. The order in which individual statements, instructions, or function calls of an imperative program are executed, or evaluated.</p></dd>", "a[href=\"#term-Casting-to-Type\"]": "<dt id=\"term-Casting-to-Type\">Casting to Type</dt><dd><p>def</p></dd>", "a[href=\"#term-Floating-Point-Numbers\"]": "<dt id=\"term-Floating-Point-Numbers\">Floating-Point Numbers</dt><dd><p>Numbers with a decimal point. Represented in code by the addition of <code class=\"docutils literal notranslate\"><span class=\"pre\">.0</span></code> to whole numbers.</p></dd>", "a[href=\"#term-Object-file\"]": "<dt id=\"term-Object-file\">Object file</dt><dd><p>The file produced by a compiler - the result of compiling a source file.</p></dd>", "a[href=\"#term-Null-Statement\"]": "<dt id=\"term-Null-Statement\">Null Statement</dt><dd><p>The <a class=\"reference internal\" href=\"#term-Empty-Statement\"><span class=\"xref std std-term\">Empty statement</span></a>: valid in C++ and can be used in certain scenarios where a statement is syntactically required but no action is needed.</p></dd>", "a[href=\"#term-Member\"]": "<dt id=\"term-Member\">Member</dt><dd><p>Types, variables and constants, and functions declared within the scope of, and therefore belonging to, a class.</p></dd>", "a[href=\"#term-Scope\"]": "<dt id=\"term-Scope\">Scope</dt><dd><p>def</p></dd>", "a[href=\"#term-Header-Files\"]": "<dt id=\"term-Header-Files\">Header Files</dt><dd><p>DEF</p></dd>", "a[href=\"#term-Modulo\"]": "<dt id=\"term-Modulo\">Modulo</dt><dd><p><a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Modulo\">Modulo</a> operation returns the remainder after dividing the lhs number by the rhs number. In C++ this operation only applies to <code class=\"docutils literal notranslate\"><span class=\"pre\">int</span></code> type and is truncating, meaning the quotient, whether positive or negative, is rounded towards before the remainder is determine. Other langugages used \u2018floored\u2019 or \u2018rounded\u2019, and for every new language you will need to determine which is applied, because different results are produced.</p></dd>", "a[href=\"#term-Control-Flow-Statements\"]": "<dt id=\"term-Control-Flow-Statements\">Control Flow Statements</dt><dd><p>Selection and iteration statements: <code class=\"docutils literal notranslate\"><span class=\"pre\">if</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">switch</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">for</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">while</span></code></p></dd>", "a[href=\"#term-Immutable\"]": "<dt id=\"term-Immutable\">Immutable</dt><dd><p>Fixed, constant, not permitted to change after initialisation.</p></dd>", "a[href=\"#term-Values\"]": "<dt id=\"term-Values\">Values</dt><dd><p>def</p></dd>", "a[href=\"#term-Literals\"]": "<dt id=\"term-Literals\">Literals</dt><dd><p>Literals are the tokens of a C++ program that represent constant values embedded in the source code.</p></dd>", "a[href=\"#term-Iteration-Statements\"]": "<dt id=\"term-Iteration-Statements\">Iteration Statements</dt><dd><p>Iterations statements include the <code class=\"docutils literal notranslate\"><span class=\"pre\">for</span></code>-statement, the <code class=\"docutils literal notranslate\"><span class=\"pre\">while</span></code>-statement and the <code class=\"docutils literal notranslate\"><span class=\"pre\">do</span></code>-statement; used to repeat the execution of a block of code until a condition is met or changes.</p></dd>", "a[href=\"#term-Namespace\"]": "<dt id=\"term-Namespace\">Namespace</dt><dd><p>def</p></dd>", "a[href=\"#term-Floating-Point-Number-Types\"]": "<dt id=\"term-Floating-Point-Number-Types\">Floating-Point Number Types</dt><dd><p>Float, Double, and Long Double. Floatig point literals are interpreted as <code class=\"docutils literal notranslate\"><span class=\"pre\">double</span></code> type unless the letter f or l is added as a suffix.</p></dd>", "a[href=\"#term-Char-Type\"]": "<dt id=\"term-Char-Type\">Char Type</dt><dd><p>Type for representing individual characters. Character literals are enclosed by <code class=\"docutils literal notranslate\"><span class=\"pre\">'</span> <span class=\"pre\">'</span></code>. Also an integer type - each character has an associate integer value.</p></dd>", "a[href=\"#term-Function-Declaration\"]": "<dt id=\"term-Function-Declaration\">Function Declaration</dt><dd><p>Statement of the name, types of any arguments and the return type of a function.</p></dd>", "a[href=\"#term-Statements\"]": "<dt id=\"term-Statements\">Statements</dt><dd><p>Statements are fragments of the C++ program that are executed in sequence, or that are used to control the execution flow. The body of any function is a sequence of statements, which may include declaration statements, <a class=\"reference internal\" href=\"#term-Expression-Statements\"><span class=\"xref std std-term\">expression statements</span></a>, and return statemends. Other statements include if-statements, while-statements, do-statements, and switch-statements. Simple statements end with a semicolon, but iteration and selection statements are terminated by <code class=\"docutils literal notranslate\"><span class=\"pre\">}</span></code> ended their code block.</p></dd>", "a[href=\"#term-Expression\"]": "<dt id=\"term-Expression\">Expression</dt><dd><p>A series of operators and names the produce a value, or may designate objects or functions. Simplest example would be an arithmetic statement.</p></dd>", "a[href=\"#term-Static\"]": "<dt id=\"term-Static\">Static</dt><dd><p>Keyword</p></dd>", "a[href=\"#term-Enumeration\"]": "<dt id=\"term-Enumeration\">Enumeration</dt><dd><p>User-defined type consisting of a set of named values.</p></dd>", "a[href=\"#term-Memory-Address\"]": "<dt id=\"term-Memory-Address\">Memory Address</dt><dd><p>A reference to a specific location in the computer\u2019s memory.</p></dd>", "a[href=\"#term-Template\"]": "<dt id=\"term-Template\">Template</dt><dd><p>A blueprint for generic and reusable code for functions and classes</p></dd>", "a[href=\"#term-Escape-Sequences\"]": "<dt id=\"term-Escape-Sequences\">Escape Sequences</dt><dd><p>Used in programming languages to represent special characters within a string or character literal. They are identified by the prefix backslash <code class=\"docutils literal notranslate\"><span class=\"pre\">\\</span></code>. Examples are <code class=\"docutils literal notranslate\"><span class=\"pre\">\\n</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">\\t</span></code>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">\\\\</span></code> to represent \u2018newline\u2019, \u2018tab\u2019 - and to identify that a backslash is just a back slash literal.</p></dd>", "a[href=\"#term-Embedded-Programs\"]": "<dt id=\"term-Embedded-Programs\">Embedded Programs</dt><dd><p>Programs written on computers and then transferred onto an embedded microprocessor in a device to control its function - also called firmware. The embedded program is an integrated part of the device and not directly accessible by the user.</p></dd>", "a[href=\"#term-Shadowing\"]": "<dt id=\"term-Shadowing\">Shadowing</dt><dd><p>For variables with the same name, the inner most scope is dominant, i.e. a local variable is used in preference to a global variable with the same name</p></dd>", "a[href=\"#term-Fundamental-Types\"]": "<dt id=\"term-Fundamental-Types\">Fundamental Types</dt><dd><p>Types provide by the core langugae.</p></dd>", "a[href=\"#term-Linker\"]": "<dt id=\"term-Linker\">Linker</dt><dd><p>The part of the C++ implementation that merges the code generated from separately compiled translation units into a program. or part of a program</p></dd>", "a[href=\"#term-Void\"]": "<dt id=\"term-Void\">Void</dt><dd><p>def</p></dd>", "a[href=\"#term-Exception\"]": "<dt id=\"term-Exception\">Exception</dt><dd><p>def</p></dd>", "a[href=\"#term-Data-Member\"]": "<dt id=\"term-Data-Member\">Data Member</dt><dd><p>Member of a class that can hold a value.</p></dd>", "a[href=\"#term-Executable-File\"]": "<dt id=\"term-Executable-File\">Executable File</dt><dd><p>def</p></dd>", "a[href=\"#term-Declarations\"]": "<dt id=\"term-Declarations\">Declarations</dt><dd><p>Declarations introduce names into a C++ program. Each kind of entity is declared differently.</p></dd>", "a[href=\"#term-Standard-Library\"]": "<dt id=\"term-Standard-Library\">Standard Library</dt><dd><p>Collecton of facilities available for inclusion into C++ programs</p></dd>", "a[href=\"#term-Memory-Management\"]": "<dt id=\"term-Memory-Management\">Memory Management</dt><dd><p>Methods of allocating and freeing memory. In C++ memory is either static, allocated on the stack, or allocated on the free store. When people talk about memory management, they usually think of free store or even specifically about garbage collection. Memory can often be effectively managed through standard library containers, such as vector or string, or through general resource management techniques.</p></dd>", "a[href=\"#term-Name\"]": "<dt id=\"term-Name\">Name</dt><dd><p>An identifier. (A minority of names are not identifiers - advanced).</p></dd>", "a[href=\"#term-Modulo-Operator\"]": "<dt id=\"term-Modulo-Operator\">Modulo Operator</dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">%</span></code> Infix operator for modulo operationsthat  returns the remainder after dividing the lhs number by the rhs number. In C++ this operation only applies to <code class=\"docutils literal notranslate\"><span class=\"pre\">int</span></code> type and is truncating, meaning the quotient, whether positive or negative, is rounded towards before the remainder is determine. Other langugages used \u2018floored\u2019 or \u2018rounded\u2019, and for every new language you will need to determine which is applied, because different results are produced.</p></dd>", "a[href=\"#term-Passing-by-Constant-Reference\"]": "<dt id=\"term-Passing-by-Constant-Reference\">Passing by Constant Reference</dt><dd><p>def</p></dd>", "a[href=\"#term-Namespaces\"]": "<dt id=\"term-Namespaces\">Namespaces</dt><dd><p>def</p></dd>", "a[href=\"#term-Integer-type\"]": "<dt id=\"term-Integer-type\">Integer type</dt><dd><p>Type for integer values (whole numbers - all both positive and negative and zero). Maybe preceded by one or two modifiers - <code class=\"docutils literal notranslate\"><span class=\"pre\">signed</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">unsigned</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">short</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">long,</span> </code>long long<code class=\"docutils literal notranslate\"><span class=\"pre\">.</span> <span class=\"pre\">The</span> <span class=\"pre\">modifiers</span> <span class=\"pre\">may</span> <span class=\"pre\">be</span> <span class=\"pre\">used</span> <span class=\"pre\">on</span> <span class=\"pre\">their</span> <span class=\"pre\">own,</span> <span class=\"pre\">and</span> <span class=\"pre\">int</span> <span class=\"pre\">is</span> <span class=\"pre\">implied;</span> <span class=\"pre\">but</span> </code>signed<code class=\"docutils literal notranslate\"><span class=\"pre\">and</span></code>unsigned<code class=\"docutils literal notranslate\"><span class=\"pre\">may</span> <span class=\"pre\">also</span> <span class=\"pre\">precede</span></code>char.</p></dd>", "a[href=\"#term-Functional-Programming\"]": "<dt id=\"term-Functional-Programming\">Functional Programming</dt><dd><p>Programming paradigm that constructed programs using functions. A declarative model of programming emphasizing \u201cwhat to do\u201d rather than \u201chow to do it.\u201d</p></dd>", "a[href=\"#term-Reserved-Characters\"]": "<dt id=\"term-Reserved-Characters\">Reserved Characters</dt><dd><p>Some characters cannot be freely used becasue the have special meaning in the syntax. Some may be overloaded. Examples: <code class=\"docutils literal notranslate\"><span class=\"pre\">#</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">\\</span></code>, arithmetic operators, comparison operators, punctuation symbols.</p></dd>", "a[href=\"#term-Constructor\"]": "<dt id=\"term-Constructor\">Constructor</dt><dd><p>def</p></dd>", "a[href=\"#term-Keyword\"]": "<dt id=\"term-Keyword\">Keyword</dt><dd><p>An identifier used by the C++ language standard. Keywords are reserved; they may not be declared as an identifier by a programmer. <a class=\"reference external\" href=\"https://en.cppreference.com/w/cpp/keywords.html\">Keywords in the C++ language</a>.</p></dd>", "a[href=\"#term-Literal\"]": "<dt id=\"term-Literal\">Literal</dt><dd><p>A fixed value written directly into a program. e.g. the number \u20181\u2019, generally found on the RHS of assignment operations. The notation used for boolean types, character types, string types, numeric types etc., e.g. the work <code class=\"docutils literal notranslate\"><span class=\"pre\">true</span></code> is a boolean literal when used appropriately.</p></dd>", "a[href=\"#term-Entities\"]": "<dt id=\"term-Entities\">Entities</dt><dd><p>The entities of a C++ program are values, objects, references, functions, enumerators, types, class members, templates, template specializations, and namespaces. ECS consists of three main parts:</p></dd>", "a[href=\"#term-Instruction-Set-Architecture\"]": "<dt id=\"term-Instruction-Set-Architecture\">Instruction Set Architecture</dt><dd><p>Specifies the format of machine code used by the programmable interface of a <a class=\"reference internal\" href=\"#term-CPU\"><span class=\"xref std std-term\">CPU</span></a>. The \u2018instuctions\u2019 are patterns of bits, each of which is unique to a specific task.</p></dd>", "a[href=\"#term-Enumerations\"]": "<dt id=\"term-Enumerations\">Enumerations</dt><dd><p>User-defined type consisting of a set of named values.</p></dd>", "a[href=\"#term-Function-Argument\"]": "<dt id=\"term-Function-Argument\">Function Argument</dt><dd><p>The values passed into a function. The function declaration specifies the number and type of the required arguments, which must match when the function is called.</p></dd>", "a[href=\"#term-Arguments\"]": "<dt id=\"term-Arguments\">Arguments</dt><dd><p>Values passed to a function or template. For templates the arguments are usually types.</p></dd>", "a[href=\"#term-Camel-Case\"]": "<dt id=\"term-Camel-Case\">Camel Case</dt><dd><p><a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Camel_case\">Camel Case</a> is one of the naming conventions used to improve the readability of code, whilst avoiding underscores.</p></dd>", "a[href=\"#term-Function-Arguments\"]": "<dt id=\"term-Function-Arguments\">Function Arguments</dt><dd><p>The values passed into a function. The function declaration specifies the number and type of the required arguments, which must match when the function is called.</p></dd>", "a[href=\"#term-Type-Checking\"]": "<dt id=\"term-Type-Checking\">Type Checking</dt><dd><p>The compiler checks every expression to ensure all objects are used correctly in accodance with their type.</p></dd>", "a[href=\"#term-Standard-Library-Facilities\"]": "<dt id=\"term-Standard-Library-Facilities\">Standard Library Facilities</dt><dd><p>The individual components of the Standard Library, made available using the <code class=\"docutils literal notranslate\"><span class=\"pre\">#include</span> <span class=\"pre\">&lt;&gt;</span></code> syntax.</p></dd>", "a[href=\"#term-Binary-File\"]": "<dt id=\"term-Binary-File\">Binary File</dt><dd><p>File containing only binary code.</p></dd>", "a[href=\"#term-Global-Scope\"]": "<dt id=\"term-Global-Scope\">Global Scope</dt><dd><p>Variables declared outside of all functions or classes have global scope. Global variables are accessible throughout the program, unless shadowed by a local variable with the same name. Global variables are best avoided unless necessary because they may result in unintended consequences in execution.</p></dd>", "a[href=\"#term-Overloading\"]": "<dt id=\"term-Overloading\">Overloading</dt><dd><p>Additing multiple defintions to the operators and functions of the same name but different parameters - each instance acts on objects of different type.</p></dd>", "a[href=\"#term-String\"]": "<dt id=\"term-String\">String</dt><dd><p>def</p></dd>", "a[href=\"#term-initialiser-List\"]": "<dt id=\"term-initialiser-List\">initialiser List</dt><dd><p>A comma-delimited list of expressions enclosed in curly braces; used to initialize a struct or an array.</p></dd>", "a[href=\"#term-Case-Sensitive\"]": "<dt id=\"term-Case-Sensitive\">Case Sensitive</dt><dd><p>Upper and lower case letters are iterprete as different symbols. If a keyword is all lower case, you must use all lower case. The name <code class=\"docutils literal notranslate\"><span class=\"pre\">myFunction</span></code> is distinct from the name <code class=\"docutils literal notranslate\"><span class=\"pre\">myfunction</span></code>. Adopting a strict convention for naming, such as <a class=\"reference internal\" href=\"#term-Camel-Case\"><span class=\"xref std std-term\">camel case</span></a> makes it easier to avoid this mistake.</p></dd>", "a[href=\"#term-Null\"]": "<dt id=\"term-Null\">Null</dt><dd><p>The integer constant zero.</p></dd>", "a[href=\"#term-Class-Members\"]": "<dt id=\"term-Class-Members\">Class Members</dt><dd><p>def</p></dd>", "a[href=\"#term-Constant\"]": "<dt id=\"term-Constant\">Constant</dt><dd><p>A variable or function parameter that is immutable - the value cannot be changed after it has been initialised.</p></dd>", "a[href=\"#term-Compiler\"]": "<dt id=\"term-Compiler\">Compiler</dt><dd><p>The part of a C++ implementation that produces object code from a translation unit. More generally compilers transform source code into other types of code, but most often into native machine code that is interpreted directly by the <a class=\"reference internal\" href=\"#term-CPU\"><span class=\"xref std std-term\">CPU</span></a>.</p></dd>", "a[href=\"#term-Constructors\"]": "<dt id=\"term-Constructors\">Constructors</dt><dd><p>def</p></dd>", "a[href=\"#term-Switch-Statement\"]": "<dt id=\"term-Switch-Statement\">Switch Statement</dt><dd><p>Def</p></dd>", "a[href=\"#term-Compound-Statement\"]": "<dt id=\"term-Compound-Statement\">Compound Statement</dt><dd><p>Sequence of <a class=\"reference internal\" href=\"#term-Statements\"><span class=\"xref std std-term\">statements</span></a> inclosed by curly braces <code class=\"docutils literal notranslate\"><span class=\"pre\">{}</span></code>. Also called a <a class=\"reference internal\" href=\"#term-Code-Block\"><span class=\"xref std std-term\">code block</span></a>.</p></dd>", "a[href=\"#term-Enumerator\"]": "<dt id=\"term-Enumerator\">Enumerator</dt><dd><p>A name identifying a value of an enumeration.</p></dd>", "a[href=\"#term-Value\"]": "<dt id=\"term-Value\">Value</dt><dd><p>def</p></dd>", "a[href=\"#term-Object-files\"]": "<dt id=\"term-Object-files\">Object files</dt><dd><p>The file produced by a compiler - the result of compiling a source file</p></dd>", "a[href=\"#term-Scope-Resolution-Operator\"]": "<dt id=\"term-Scope-Resolution-Operator\">Scope Resolution Operator</dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">::</span></code> -  links an entity to its container; like a folder reference.</p></dd>", "a[href=\"#term-Resource-files\"]": "<dt id=\"term-Resource-files\">Resource files</dt><dd><p>Non code files, such as image files, required by the program.</p></dd>", "a[href=\"#term-Flow-Control\"]": "<dt id=\"term-Flow-Control\">Flow Control</dt><dd><p>Control of the sequential flow of execution.</p></dd>", "a[href=\"#term-Translation-unit\"]": "<dt id=\"term-Translation-unit\">Translation unit</dt><dd><p>Part of a program that can be separately compiled. Individual source, or header, files.</p></dd>", "a[href=\"#term-Entity\"]": "<dt id=\"term-Entity\">Entity</dt><dd><p>The entities of a C++ program are values, objects, references, functions, enumerators, types, class members, templates, template specializations, and namespaces. ECS consists of three main parts:</p></dd>", "a[href=\"#term-CPU\"]": "<dt id=\"term-CPU\">CPU</dt><dd><p><a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Central_processing_unit\">Central Processing Unit</a> is the electronic circuitry inside a computer that executes the machine code version of computer programmes.</p></dd>", "a[href=\"#term-Initialisation\"]": "<dt id=\"term-Initialisation\">Initialisation</dt><dd><p>Setting the initial value of an object. Defintion results when initialisation is added to a declaration. Initialization is different from assignment because there is no previous value involved and initialization is done by <a class=\"reference internal\" href=\"#term-Constructors\"><span class=\"xref std std-term\">constructors</span></a>.</p></dd>", "a[href=\"#term-Iteration-Statement\"]": "<dt id=\"term-Iteration-Statement\">Iteration Statement</dt><dd><p>terations statements include the <code class=\"docutils literal notranslate\"><span class=\"pre\">for</span></code>-statement, the <code class=\"docutils literal notranslate\"><span class=\"pre\">while</span></code>-statement and the <code class=\"docutils literal notranslate\"><span class=\"pre\">do</span></code>-statement; used to repeat the execution of a block of code until a condition is met or changes.</p></dd>", "a[href=\"#term-Types\"]": "<dt id=\"term-Types\">Types</dt><dd><p>A type defines the proper use of a name or an expression.</p></dd>", "a[href=\"#term-Concatenation\"]": "<dt id=\"term-Concatenation\">Concatenation</dt><dd><p>Joining of two strings together.</p></dd>", "a[href=\"#term-Infix-Operator\"]": "<dt id=\"term-Infix-Operator\">Infix Operator</dt><dd><p>Operator that sits between two variables, denoting an operation using both. As opposed to unary, prefix and postfix operators that act on one variable position before or after it.</p></dd>", "a[href=\"#term-Comments\"]": "<dt id=\"term-Comments\">Comments</dt><dd><p>Comments are text in a computer program that is only intended as a note to the progammer. Comments are useful as in-code documentation, and also allow part of program to be hidden from the compiler temporarily during development.</p></dd>", "a[href=\"#term-Static-Memory\"]": "<dt id=\"term-Static-Memory\">Static Memory</dt><dd><p>Memory allocated by the <a class=\"reference internal\" href=\"#term-Linker\"><span class=\"xref std std-term\">linker</span></a></p></dd>", "a[href=\"#term-Variable\"]": "<dt id=\"term-Variable\">Variable</dt><dd><p>A variable is an object or a reference that is not a non-static data member, that is introduced by a declaration - a named object in a scope.</p></dd>", "a[href=\"#term-Function-Parameter\"]": "<dt id=\"term-Function-Parameter\">Function Parameter</dt><dd><p>Placeholders in the function declaration for the arguments that will be passed in. The parameter is the local variable name within the function associated with its argument value.</p></dd>", "a[href=\"#term-Assignment\"]": "<dt id=\"term-Assignment\">Assignment</dt><dd><p>DEf</p></dd>", "a[href=\"#term-Algorithm\"]": "<dt id=\"term-Algorithm\">Algorithm</dt><dd><p>Algorithm: A sequence of steps or rules to solve a problem, often implemented using STL (Standard Template Library).</p></dd>", "a[href=\"#term-Dynamic-Memory\"]": "<dt id=\"term-Dynamic-Memory\">Dynamic Memory</dt><dd><p>Memory that is allocated during runtime using <code class=\"docutils literal notranslate\"><span class=\"pre\">new</span></code>; and deallocated using <code class=\"docutils literal notranslate\"><span class=\"pre\">delete</span></code>.</p></dd>", "a[href=\"#term-Type-Conversion\"]": "<dt id=\"term-Type-Conversion\">Type Conversion</dt><dd><p>Alternative name for type casting.</p></dd>", "a[href=\"#term-Type-Safety\"]": "<dt id=\"term-Type-Safety\">Type Safety</dt><dd><p>The property that an object can be accessed only according to its definition. C++ is higly type safe, but a programmer can still violate type safety by explicit casting, by using an uninitialized variable, by using a pointer that doesn\u2019t point to an object, by accessing beyond the end of an array, and by misusing a union. Type safety must be preserved for a program to be correct and maintainable.</p></dd>", "a[href=\"#term-Falling-Through\"]": "<dt id=\"term-Falling-Through\">Falling Through</dt><dd><p>When a program reaches the end of code block and just continues onto the next statements. Will be an error for a function if a return is expected, but permitted for <code class=\"docutils literal notranslate\"><span class=\"pre\">void</span></code>.</p></dd>", "a[href=\"#term-Assignment-Operator\"]": "<dt id=\"term-Assignment-Operator\">Assignment Operator</dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">=</span></code></p></dd>", "a[href=\"#term-Expression-Statement\"]": "<dt id=\"term-Expression-Statement\">Expression Statement</dt><dd><p>An expression followed by a semicolon.</p></dd>", "a[href=\"#term-Object-oriented-programming\"]": "<dt id=\"term-Object-oriented-programming\">Object-oriented programming</dt><dd><p>Programming paradigm that encapsulates related data and functions into objects. An imperative model, focusing on \u201chow to do\u201d tasks step-by-step.</p></dd>", "a[href=\"#term-Definitions\"]": "<dt id=\"term-Definitions\">Definitions</dt><dd><p>Definitions are declarations that are sufficient to use the entity identified by the name.</p></dd>", "a[href=\"#term-int\"]": "<dt id=\"term-int\">int</dt><dd><p>Key word for the Integer type.</p></dd>", "a[href=\"#term-Local-Variables\"]": "<dt id=\"term-Local-Variables\">Local Variables</dt><dd><p>Definition</p></dd>", "a[href=\"#term-Narrowing\"]": "<dt id=\"term-Narrowing\">Narrowing</dt><dd><p>A narrowing (conversion) occurs when a value is converted from one type to another and the new type is not big enough to represent all possible values of the original type; leading to data loss or undefined behaviors.</p></dd>", "a[href=\"#term-Code-Block\"]": "<dt id=\"term-Code-Block\">Code Block</dt><dd><p>Sequence of <a class=\"reference internal\" href=\"#term-Statements\"><span class=\"xref std std-term\">statements</span></a> inclosed by curly braces <code class=\"docutils literal notranslate\"><span class=\"pre\">{}</span></code>. Also called a <a class=\"reference internal\" href=\"#term-Compound-Statement\"><span class=\"xref std std-term\">compound statement</span></a>.</p></dd>", "a[href=\"#term-Programming-Paradigms\"]": "<dt id=\"term-Programming-Paradigms\">Programming Paradigms</dt><dd><p>Different approaches to writing computer programs. Most common paradigms are: Procedural, Functional, and Object-oriented programming.</p></dd>", "a[href=\"#term-Keywords\"]": "<dt id=\"term-Keywords\">Keywords</dt><dd><p>An identifier used by the C++ language standard. Keywords are reserved; they may not be declared as an identifier by a programmer. <a class=\"reference external\" href=\"https://en.cppreference.com/w/cpp/keywords.html\">Keywords in the C++ language</a>.</p></dd>", "a[href=\"#glossary\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Glossary<a class=\"headerlink\" href=\"#glossary\" title=\"Permalink to this heading\">#</a></h1>", "a[href=\"#term-Function\"]": "<dt id=\"term-Function\">Function</dt><dd><p>A named sequence of statements that can be invoked/called by a program, optionally using arguments supplied by the function call, to optionall return a value to the program. The type of the function includes the number and types of argument and the type of the value returned. Functions are useful because they are reusable, making code more efficient to write and execute.</p></dd>", "a[href=\"#term-Passing-by-Reference\"]": "<dt id=\"term-Passing-by-Reference\">Passing by Reference</dt><dd><p>If a function parameter type is declared to be a reference to a type, then a reference to a variable can be passed instead of the variable itself. This saves the memory overhead needed to create the local copy of the passed in value, and allows the function to operate on the orginal value instead. Also called call-by-reference, as opposed to call-by-value when the actual value is passed in.</p></dd>", "a[href=\"#term-Compiled-Language\"]": "<dt id=\"term-Compiled-Language\">Compiled Language</dt><dd><p>def</p></dd>", "a[href=\"#term-Functions\"]": "<dt id=\"term-Functions\">Functions</dt><dd><p>A named sequence of statements that can be invoked/called by a program, optionally using arguments supplied by the function call, to optionall return a value to the program. The type of the function includes the number and types of argument and the type of the value returned. Functions are useful because they are reusable, making code more efficient to write and execute.</p></dd>", "a[href=\"#term-Function-Call\"]": "<dt id=\"term-Function-Call\">Function Call</dt><dd><p>A function is \u2018called\u2019 or \u2018invoked\u2019 by a statement of the function name followed by the values to be passed to the function in parenthesis. Any value returned by the function can be used by <a class=\"reference internal\" href=\"#term-Copy-Assignment\"><span class=\"xref std std-term\">copy assignment</span></a>.</p></dd>", "a[href=\"#term-Type-Casting\"]": "<dt id=\"term-Type-Casting\">Type Casting</dt><dd><p>Assigning a value of a different type to an object of a new type. Casting/conversion can be implicit or explicit.</p></dd>", "a[href=\"#term-References\"]": "<dt id=\"term-References\">References</dt><dd><p>def</p></dd>", "a[href=\"#term-Type-System\"]": "<dt id=\"term-Type-System\">Type System</dt><dd><p>The set of rules prescribing how each object may be used according to their types.</p></dd>", "a[href=\"#term-List-Initialisation\"]": "<dt id=\"term-List-Initialisation\">List Initialisation</dt><dd><p>Initialisatin using <code class=\"docutils literal notranslate\"><span class=\"pre\">{}</span></code>; e.g int myInt {intial value or expression to produce the intial value}</p></dd>", "a[href=\"#term-Linkage\"]": "<dt id=\"term-Linkage\">Linkage</dt><dd><p>The process of merging code from separately compiled translation units into a program or part of a program.</p></dd>", "a[href=\"#term-Heap\"]": "<dt id=\"term-Heap\">Heap</dt><dd><p>def</p></dd>", "a[href=\"#term-Named-Object\"]": "<dt id=\"term-Named-Object\">Named Object</dt><dd><p>A variable</p></dd>", "a[href=\"#term-Definition\"]": "<dt id=\"term-Definition\">Definition</dt><dd><p>Definitions are declarations that are sufficient to use the entity identified by the name.</p></dd>", "a[href=\"#term-Class\"]": "<dt id=\"term-Class\">Class</dt><dd><p>more basic    ;A blueprint for creating objects, encapsulating data (attributes) and functions (methods).</p></dd>", "a[href=\"#term-Templates\"]": "<dt id=\"term-Templates\">Templates</dt><dd><p>A blueprint for generic and reusable code for functions and classes</p></dd>", "a[href=\"#term-Identifier\"]": "<dt id=\"term-Identifier\">Identifier</dt><dd><p>The <a class=\"reference internal\" href=\"#term-Name\"><span class=\"xref std std-term\">name</span></a> given to any <a class=\"reference internal\" href=\"#term-Entity\"><span class=\"xref std std-term\">entity</span></a> that may have a used defined name.</p></dd>", "a[href=\"#term-Syntax\"]": "<dt id=\"term-Syntax\">Syntax</dt><dd><p>The set of gramatical rules specifying how the text of a program must be composed. For example, specifying the form of a declaration or the form of a for-statement.</p></dd>", "a[href=\"#term-Function-Body\"]": "<dt id=\"term-Function-Body\">Function Body</dt><dd><p>Sequence of statement to be executed when the function is called.</p></dd>", "a[href=\"#term-ASCII\"]": "<dt id=\"term-ASCII\">ASCII</dt><dd><p>American Standard Code for Information Interchange -  a character encoding standard that represents text in computers and other devices. It uses 7 bits to encode 128 characters.</p></dd>", "a[href=\"#term-Numeric-Data-Type\"]": "<dt id=\"term-Numeric-Data-Type\">Numeric Data Type</dt><dd><p>The data types for numeric values - each represents a different type of number to different levels of precision. Includes <code class=\"docutils literal notranslate\"><span class=\"pre\">int</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">float</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">double</span></code>. Some data types require additional specficiers, see the <a class=\"reference external\" href=\"https://en.cppreference.com/w/cpp/language/types.html\">C++ Reference - Data Types</a></p></dd>", "a[href=\"#term-Type\"]": "<dt id=\"term-Type\">Type</dt><dd><p>A type defines the proper use of a name or an expression.</p></dd>", "a[href=\"#term-Reference\"]": "<dt id=\"term-Reference\">Reference</dt><dd><p>def</p></dd>", "a[href=\"#term-Expression-Statements\"]": "<dt id=\"term-Expression-Statements\">Expression Statements</dt><dd><p>An expression followed by a semicolon.</p></dd>", "a[href=\"https://en.cppreference.com/w/cpp/keywords.html\"]": "<p>Keywords</p>"}
skip_classes = ["headerlink", "sd-stretched-link"]

window.onload = function () {
    for (const [select, tip_html] of Object.entries(selector_to_html)) {
        const links = document.querySelectorAll(` ${select}`);
        for (const link of links) {
            if (skip_classes.some(c => link.classList.contains(c))) {
                continue;
            }

            tippy(link, {
                content: tip_html,
                allowHTML: true,
                arrow: true,
                placement: 'auto-start', maxWidth: 500, interactive: false, theme: 'material', duration: [200, 100], delay: [200, 0],

            });
        };
    };
    console.log("tippy tips loaded!");
};
