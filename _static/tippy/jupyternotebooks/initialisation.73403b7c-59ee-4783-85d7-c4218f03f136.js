selector_to_html = {"a[href=\"glossary.html#term-Constructor\"]": "<dt id=\"term-Constructor\">Constructor</dt><dd><p>A special member function that is automatically called when an object of its class is created. Constructors have the same name as their class and have no return type (not even <code class=\"docutils literal notranslate\"><span class=\"pre\">void</span></code>).</p></dd>", "a[href=\"#empty-initialiser-list-value-initialisation-and-zero-initialisation\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Empty Initialiser List - Value-Initialisation and Zero-Initialisation<a class=\"headerlink\" href=\"#empty-initialiser-list-value-initialisation-and-zero-initialisation\" title=\"Permalink to this heading\">#</a></h2><p>If an object is intialised with an empty initialiser list <code class=\"docutils literal notranslate\"><span class=\"pre\">{}</span></code> it is first zero-intialised, and then value-initialised if possible.</p><p>If the variable is a <a class=\"reference internal\" href=\"glossary.html#term-Scalar\"><span class=\"xref std std-term\">scalar</span></a> (arithmetic, pointer, or enum type) they are only zero-inititialised.</p>", "a[href=\"glossary.html#term-Scalar\"]": "<dt id=\"term-Scalar\">Scalar</dt><dd><p>A type that holds a single value of a defined range. Scalars include arithmetic types (integral or floating-point values), enumeration type members, pointer types, pointer-to-member types, and std::nullptr_t. Fundamental types are typically scalar types.</p></dd>", "a[href=\"glossary.html#term-Narrowing\"]": "<dt id=\"term-Narrowing\">Narrowing</dt><dd><p>A narrowing (conversion) occurs when a value is converted from one type to another and the new type is not big enough to represent all possible values of the original type; leading to data loss or undefined behaviours.</p></dd>", "a[href=\"glossary.html#term-Initialiser\"]": "<dt id=\"term-Initialiser\">Initialiser</dt><dd><p>def</p></dd>", "a[href=\"arithmetic_data_types.html#sizeofnumericvalues\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Max Size of Numeric Values<a class=\"headerlink\" href=\"#max-size-of-numeric-values\" title=\"Permalink to this heading\">#</a></h2><p>The maximum value that can be storde by each <a class=\"reference internal\" href=\"glossary.html#term-Numeric-Data-Type\"><span class=\"xref std std-term\">numeric data type</span></a> depends on number of bits used by the computer architecture.</p><p>Most computers use 64 bits, meaning that 64 bits are used to represent addresses in memory, allowing larger numbers to be stored.</p>", "a[href=\"glossary.html#term-Static-Duration\"]": "<dt id=\"term-Static-Duration\">Static Duration</dt><dd><p>Lifetime of the programme\u2019s execution - duration of static variables - all global variables.</p></dd>", "a[href=\"#initialisation\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Initialisation<a class=\"headerlink\" href=\"#initialisation\" title=\"Permalink to this heading\">#</a></h1><p><a class=\"reference internal\" href=\"glossary.html#term-Initialisation\"><span class=\"xref std std-term\">Initialisation</span></a> is the setting of the intial value of a variable at the time of <a class=\"reference internal\" href=\"glossary.html#term-Construction\"><span class=\"xref std std-term\">construction</span></a>.</p><p><span class=\"xref std std-term\">Definiton</span> is therefore <span class=\"xref std std-term\">decalaration</span> combined with initialisation.</p>", "a[href=\"glossary.html#term-Construction\"]": "<dt id=\"term-Construction\">Construction</dt><dd><p>Creating a new object \u2013 also called instantiation, when referring to a class.</p></dd>", "a[href=\"#initialiser-lists\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Initialiser Lists<a class=\"headerlink\" href=\"#initialiser-lists\" title=\"Permalink to this heading\">#</a></h2><p>More complicated objects can require more than one value as an initializer. This is primarily handled by initializer\nLists delimited by { and }. For example:</p>", "a[href=\"#auto\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Auto<a class=\"headerlink\" href=\"#auto\" title=\"Permalink to this heading\">#</a></h2><p>The type of simple variable can be deduced fr</p><p>When defining a variable, you don\u2019t actually need to state its type explicitly when it can be deduced from the initializer:</p>", "a[href=\"#missing-initialisers-default-initialisation\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Missing Initialisers - Default Initialisation?<a class=\"headerlink\" href=\"#missing-initialisers-default-initialisation\" title=\"Permalink to this heading\">#</a></h2><p>When no initialiser is specified, either no initialisation happens or the object is {term}`default-initialised.</p><p>The manner of default-initialisation depends on the entity. Objects can be default-initialized, but if no initializer is specified for a reference, the program is ill-formed.</p>", "a[href=\"glossary.html#term-Assignment-Operator\"]": "<dt id=\"term-Assignment-Operator\">Assignment Operator</dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">=</span></code>. The simple assignment operator, there are others. Used to assign a value to a variable, by literal assignment, <a class=\"reference internal\" href=\"#term-Copy-Assignment\"><span class=\"xref std std-term\">copy assignment</span></a>, or evaluation assignment, including as<a class=\"reference internal\" href=\"#term-Initialisation\"><span class=\"xref std std-term\">initialisation</span></a>.</p></dd>", "a[href=\"#initialisers\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Initialisers<a class=\"headerlink\" href=\"#initialisers\" title=\"Permalink to this heading\">#</a></h2><p>There a different ways to intialise an object.</p><p>If an <a class=\"reference internal\" href=\"glossary.html#term-Initialiser\"><span class=\"xref std std-term\">initialiser</span></a> is specified for an object, that initializer determines the initial value of an object.</p>", "a[href=\"#zero-initialization\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Zero-initialization<a class=\"headerlink\" href=\"#zero-initialization\" title=\"Permalink to this heading\">#</a></h3><p>Initialisation of variable to the zero value of its type:</p>", "a[href=\"glossary.html#term-List-Initialisation\"]": "<dt id=\"term-List-Initialisation\">List Initialisation</dt><dd><p>Initialization using <code class=\"docutils literal notranslate\"><span class=\"pre\">{}</span></code>; e.g. int myInt {initial value or expression to produce the initial value}</p></dd>", "a[href=\"glossary.html#term-Default-Constructor\"]": "<dt id=\"term-Default-Constructor\">Default Constructor</dt><dd><p>Constructor that be called with not arguments - use to construct an object when no user initialisation is provided.</p></dd>", "a[href=\"glossary.html#term-Initialisation\"]": "<dt id=\"term-Initialisation\">Initialisation</dt><dd><p>Setting the initial value of an object. Definition results when initialisation is added to a declaration. Initialization is different from assignment because the object had no previous value and initialization is done by <a class=\"reference internal\" href=\"#term-Constructors\"><span class=\"xref std std-term\">constructors</span></a>.</p></dd>"}
skip_classes = ["headerlink", "sd-stretched-link"]

window.onload = function () {
    for (const [select, tip_html] of Object.entries(selector_to_html)) {
        const links = document.querySelectorAll(` ${select}`);
        for (const link of links) {
            if (skip_classes.some(c => link.classList.contains(c))) {
                continue;
            }

            tippy(link, {
                content: tip_html,
                allowHTML: true,
                arrow: true,
                placement: 'auto-start', maxWidth: 500, interactive: false, theme: 'material', duration: [200, 100], delay: [200, 0],

            });
        };
    };
    console.log("tippy tips loaded!");
};
