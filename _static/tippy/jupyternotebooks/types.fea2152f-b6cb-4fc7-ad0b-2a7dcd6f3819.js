selector_to_html = {"a[href=\"#deducing-a-type-auto-and-decltype\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Deducing a Type: auto and decltype()<a class=\"headerlink\" href=\"#deducing-a-type-auto-and-decltype\" title=\"Permalink to this heading\">#</a></h2><p>C++ provides two mechanisms for deducing a type from an expression - or rather for reporting the type that is already known to the compiler.</p><p><code class=\"docutils literal notranslate\"><span class=\"pre\">auto</span></code> for deducing a type of an object from its initializer; the type can be the type of a variable, a <code class=\"docutils literal notranslate\"><span class=\"pre\">const</span></code>, or a <code class=\"docutils literal notranslate\"><span class=\"pre\">constexpr</span></code>.</p>", "a[href=\"#determining-the-type-of-a-variable\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Determining the Type of a Variable<a class=\"headerlink\" href=\"#determining-the-type-of-a-variable\" title=\"Permalink to this heading\">#</a></h2><p>It is tremendously useful to be able to check the type of a variable.</p>", "a[href=\"#lvalue-and-rvalue-advanced\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">lvalue and rvalue (Advanced)<a class=\"headerlink\" href=\"#lvalue-and-rvalue-advanced\" title=\"Permalink to this heading\">#</a></h2><p>The C++ term <a class=\"reference internal\" href=\"glossary.html#term-lvalue\"><span class=\"xref std std-term\">lvalue</span></a> was originally coined to mean \u2018something that can be on the left-hand side of an assignment\u2019.</p><p>lvalues are named objects, or an unnamed object created using <code class=\"docutils literal notranslate\"><span class=\"pre\">new</span></code>. Not all lvalues may be used on the left-hand side of an assignment, for example if the lvalue refers to a constant.</p>", "a[href=\"#casting-to-type\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Casting to Type<a class=\"headerlink\" href=\"#casting-to-type\" title=\"Permalink to this heading\">#</a></h2><p>Although the type of a variable cannot be changed, the value of a variable can be copy assigned to a different variable that has a different type - not all permutations are permitted.</p><p>Casting to type, means conversion from the original type to the type of the variable that the value is being assigned. This is often useful, and often necessary when working with numeric types.</p>", "a[href=\"glossary.html#term-Infix-Operator\"]": "<dt id=\"term-Infix-Operator\">Infix Operator</dt><dd><p>Operator that sits between two variables, denoting an operation using both variable (the operands). As opposed to unary, prefix and postfix, operators that act on one variable positioned before or after it respectively.</p></dd>", "a[href=\"#explicit-casting\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Explicit Casting<a class=\"headerlink\" href=\"#explicit-casting\" title=\"Permalink to this heading\">#</a></h3><p>Some types may be explicitly cast to another, using a type conversion function - there are several methods.</p><p>Function style casting is the simplest - e.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">int()</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">double()</span></code>. These functions do not actually alter the original type; they just create a converted copy to be used in the expression.</p>", "a[href=\"glossary.html#term-rvalue\"]": "<dt id=\"term-rvalue\">rvalue</dt><dd><p>The expression appearing on the right-hand side of an assignment operator or in the {} for list initialisation. rvalues are not always on the RHS, but if the same expression could be used on RHS, it\u2019s probably an rvalue. rvalue expressions including literals, function calls, arithmetic and logical evaluations and comparisons, whose evaluation computes the value of an operand of a built-in operator (no result object) or initializes an object (a result object is created). The result object may be a variable, an object created by new-expression, or a temporary created by temporary materialization. An rvalue expression is either prvalue or xvalue \u2013 see the cppreference for details.</p></dd>", "a[href=\"glossary.html#term-Core-Language\"]": "<dt id=\"term-Core-Language\">Core Language</dt><dd><p>The fundamental components of the C++ language not found in the Standard Library, whose  libraries are constructed from the core language.</p></dd>", "a[href=\"glossary.html#term-Void\"]": "<dt id=\"term-Void\">Void</dt><dd><p>Used to declare that a function returns nothing. Cannot be used to declare a variable as having no type. Used to declare that a pointer is of universal type i.e. void* pointer to a name that\u2019s type is not defined yet.</p></dd>", "a[href=\"glossary.html#term-Class\"]": "<dt id=\"term-Class\">Class</dt><dd><p>A user-defined data type - a blueprint for creating objects, encapsulating data (attributes) and functions (methods).</p></dd>", "a[href=\"#type-aliases\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Type Aliases<a class=\"headerlink\" href=\"#type-aliases\" title=\"Permalink to this heading\">#</a></h2><p>Sometimes, we need a new name for a type.</p><p>Possible reasons include:</p>", "a[href=\"#type-system-and-type-safety\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Type System and Type Safety<a class=\"headerlink\" href=\"#type-system-and-type-safety\" title=\"Permalink to this heading\">#</a></h2><p>All expressions (including literal values) are implicitly given a type by the compiler before they\u2019re evaluated.</p><p>The C++ type system is a fundamental aspect of the language - a set of rules applied by the compiler that ensure every variable, function argument, return value, and expression has a specific type.</p>", "a[href=\"#implicit-casting\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Implicit Casting<a class=\"headerlink\" href=\"#implicit-casting\" title=\"Permalink to this heading\">#</a></h3><p>Some types are automatically converted by the compiler if there is a mismatch and the type conversion required is one of the permitted built-in conversions - called implicit casting.</p><p>Implicit casting occurs when a single expression is found to include multiple types - e.g. the attempted addition of an <code class=\"docutils literal notranslate\"><span class=\"pre\">int</span></code> to a <code class=\"docutils literal notranslate\"><span class=\"pre\">double</span></code> - although they are both numbers, a decision needs to be made about the type of the result, and some possible operations behave differently between types, such as division.</p>", "a[href=\"glossary.html#term-Fundamental-Types\"]": "<dt id=\"term-Fundamental-Types\">Fundamental Types</dt><dd><p>Types provide by the <a class=\"reference internal\" href=\"#term-Core-Language\"><span class=\"xref std std-term\">core language</span></a>.</p></dd>", "a[href=\"glossary.html#term-Standard-Library\"]": "<dt id=\"term-Standard-Library\">Standard Library</dt><dd><p>Collection of facilities (classes and functions) available for inclusion into C++ programmes \u2013 separated into namespaces.</p></dd>", "a[href=\"#c-is-a-strongly-typed-language\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">C++ is a Strongly-typed Language.<a class=\"headerlink\" href=\"#c-is-a-strongly-typed-language\" title=\"Permalink to this heading\">#</a></h2><p>Once a variable\u2019s type has been declared, for example when a number is cast as a <code class=\"docutils literal notranslate\"><span class=\"pre\">double</span></code>, the type cannot be changed.</p><p>However, type conversion is possible - by copying the value from a variable of one type to a new variable of the different type. This is called <a class=\"reference internal\" href=\"glossary.html#term-Casting-to-Type\"><span class=\"xref std std-term\">casting to type</span></a>.</p>", "a[href=\"glossary.html#term-Casting-to-Type\"]": "<dt id=\"term-Casting-to-Type\">Casting to Type</dt><dd><p>Conversion of one type of data safely to another. A variable cannot change its type, so type casting occurs on assignment to a variable of the correct type.</p></dd>", "a[href=\"glossary.html#term-Template\"]": "<dt id=\"term-Template\">Template</dt><dd><p>A blueprint for generic and reusable code for functions and classes.</p></dd>", "a[href=\"glossary.html#term-Type\"]": "<dt id=\"term-Type\">Type</dt><dd><p>A type defines the proper use of a name or an expression.</p></dd>", "a[href=\"#fundamental-types-in-c\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Fundamental Types in C++<a class=\"headerlink\" href=\"#fundamental-types-in-c\" title=\"Permalink to this heading\">#</a></h2><p>Types defined in the <a class=\"reference internal\" href=\"glossary.html#term-Core-Language\"><span class=\"xref std std-term\">core language</span></a> are called the <a class=\"reference internal\" href=\"glossary.html#term-Fundamental-Types\"><span class=\"xref std std-term\">fundamental types</span></a>:</p>", "a[href=\"#types-in-c\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Types in C++<a class=\"headerlink\" href=\"#types-in-c\" title=\"Permalink to this heading\">#</a></h1><p>The <a class=\"reference internal\" href=\"glossary.html#term-Type\"><span class=\"xref std std-term\">type</span></a> of a variable defines its properties, the rules it must obey, and the set of operators and functions available to members of that type.</p><p>For example, <code class=\"docutils literal notranslate\"><span class=\"pre\">+</span></code> behaves differently when used an <a class=\"reference internal\" href=\"glossary.html#term-Infix-Operator\"><span class=\"xref std std-term\">infix operator</span></a> between two integers, compared to between two strings.</p>", "a[href=\"glossary.html#term-lvalue\"]": "<dt id=\"term-lvalue\">lvalue</dt><dd><p>An expression whose evaluation determines the identity of an object or function. The name of the object or function - basically, the left-hand side of an assignment operation or the name before the {}.</p></dd>"}
skip_classes = ["headerlink", "sd-stretched-link"]

window.onload = function () {
    for (const [select, tip_html] of Object.entries(selector_to_html)) {
        const links = document.querySelectorAll(` ${select}`);
        for (const link of links) {
            if (skip_classes.some(c => link.classList.contains(c))) {
                continue;
            }

            tippy(link, {
                content: tip_html,
                allowHTML: true,
                arrow: true,
                placement: 'auto-start', maxWidth: 500, interactive: false, theme: 'material', duration: [200, 100], delay: [200, 0],

            });
        };
    };
    console.log("tippy tips loaded!");
};
