selector_to_html = {"a[href=\"#pointers-into-arrays\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Pointers into Arrays<a class=\"headerlink\" href=\"#pointers-into-arrays\" title=\"Link to this heading\">#</a></h2><p>In C++, pointers and arrays are closely related. The name of an array can be used as a pointer to its initial element. For example:\nint v[] = { 1, 2, 3, 4 };\nint* p1 = v; // pointer to initial element (implicit conversion)\nint* p2 = &amp;v[0]; // pointer to initial element\nint* p3 = v + 4; // pointer to one-beyond-last element\nint* p4 = v + 2; // pointer to other elements\nstd::cout &lt;&lt; v &lt;&lt; \u2018\\n\u2019;\nstd::cout &lt;&lt; p1 &lt;&lt; \u2018\\n\u2019;\nstd::cout &lt;&lt; *p1 &lt;&lt; \u2018\\n\u2019;\nstd::cout &lt;&lt; p3 &lt;&lt; \u2018\\n\u2019;\nstd::cout &lt;&lt; <em>p3 &lt;&lt; \u2018\\n\u2019;\nstd::cout &lt;&lt; p4 &lt;&lt; \u2018\\n\u2019;\nstd::cout &lt;&lt; <em>p4 &lt;&lt; \u2018\\n\u2019;\nTaking a pointer to the element one beyond the end of an array is guaranteed to work. This is important for many algorithms However, since such a pointer does not in fact point to an element of the array, it may not be used for reading or writing. The result of taking the address of the element before the initial element or beyond one-past-the-last element is undefined and should be avoided. For example:\nint</em> p4 = v\u22121; // before the beginning, undefined: don\u2019t do it\nint</em> p5 = v + 7; // beyond the end, undefined: don\u2019t do it</p><p>The implicit conversion of an array name to a pointer to the initial element of the array is extensively used in function calls in C-style code. For example:\n// extern \u201cC\u201d int strlen(const char*);   // from &lt;string.h&gt;\nvoid f() {\nchar v[] = \u201cAnnemarie\u201d;\nchar* p = v;  // implicit conversion of char[] to char*\nstd::cout &lt;&lt;strlen(p) &lt;&lt; \u2018\\n\u2019;\nstd::cout &lt;&lt; strlen(v) &lt;&lt; \u2018\\n\u2019;   // implicit conversion of char[] to char*\n//v = p;     // error: cannot assign to array }\nint main() { f(); }\nThe same value is passed to the standard-library function strlen() in both calls. The snag is that it is impossible to avoid the implicit conversion. In other words, there is no way of declaring a function so that the array v is copied when the function is called. Fortunately, there is no implicit or explicit conversion from a pointer to an array.\nThe implicit conversion of the array argument to a pointer means that the size of the array is lost to the called function. However, the called function must somehow determine the size to perform a meaningful operation. Like other C standard-library functions taking pointers to characters, strlen() relies on zero to indicate end-of-string; strlen(p) returns the number of characters up to and not including the terminating 0. This is all pretty low-level. The standard-library vector, array, and string don\u2019t suffer from this problem. These library types give their number of elements as their size() without having to count elements each time.</p>", "a[href=\"#nullptr\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\"><code class=\"docutils literal notranslate\"><span class=\"pre\">nullptr</span></code><a class=\"headerlink\" href=\"#nullptr\" title=\"Link to this heading\">#</a></h2><p>The literal nullptr represents the null pointer, that is, a pointer that does not point to an object. It can be assigned to any pointer type, but not to other built-in types:\nint* pi = nullptr;  double* pd = nullptr;     int i = nullptr;      // error: i is not a pointer\nint* p = NULL; // using the macro NULL\nThere is just one nullptr, which can be used for every pointer type, rather than a null pointer for each pointer type.\nBefore nullptr was introduced, zero (0) was used as a notation for the null pointer. For example:\nint* x= 0; // x gets the value nullptr\nNo object is allocated with the address 0, and 0 (the all-zeros bit pattern) is the most common repre- sentation of nullptr. Zero (0) is an int. However, the standard conversions allow 0 to be used as a constant of pointer or pointer-to-member type.\nIt has been popular to define a macro NULL to represent the null pointer. For example:\nHowever, there are differences in the definition of NULL in different implementations; for example,\nNULL might be 0 or 0L. In C, NULL is typically (void*)0, which makes it illegal in C++:\nint* p = NULL; // error: can\u2019t assign a void* to an int*\nUsing nullptr makes code more readable than alternatives and avoids potential confusion when a function is overloaded to accept either a pointer or an integer.</p>", "a[href=\"#pointer-expressions-and-arithmetic\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Pointer Expressions and Arithmetic<a class=\"headerlink\" href=\"#pointer-expressions-and-arithmetic\" title=\"Link to this heading\">#</a></h2><p>A limited set of arithmetic operations can be performed on pointers which are:</p><p>incremented ( ++ )\ndecremented ( \u2014 )\nan integer may be added to a pointer ( + or += )\nan integer may be subtracted from a pointer ( \u2013 or -= )\ndifference between two pointers (p1-p2)</p>", "a[href=\"#pointers-and-booleans\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Pointers and Booleans<a class=\"headerlink\" href=\"#pointers-and-booleans\" title=\"Link to this heading\">#</a></h2><p>A pointer can be implicitly converted to a bool. A non-null pointer converts to true; pointers with the value nullptr convert to false. void myFunction(int* myPointer)\n{\nbool myBoolean1 = myPointer;       // narrows to true or false - not a copy!\nstd::cout &lt;&lt; myBoolean1 &lt;&lt; \u2018\\n\u2019;\nbool myBoolean2{ myPointer != nullptr };  // explicit test against nullptr\nstd::cout &lt;&lt; myBoolean1 &lt;&lt; \u2018\\n\u2019;\nif (myPointer) {\n// identical to p!=nullptr\nstd::cout &lt;&lt; \u201cnot pointing to Null\u201d &lt;&lt; \u2018\\n\u2019;\n}\n}\nint main() {\nint temp = 17;\nint* myPointerToTemp = nullptr; // or set to temp\nmyFunction(myPointerToTemp);\n\u00a0\nreturn 0;\n}\nI prefer if (p) over if (p!=nullptr) because it more directly expresses the notion \u2018\u2018if p is valid\u2019\u2019 and also because it is shorter. The shorter form leaves fewer opportunities for mistakes.</p>", "a[href=\"#pointers-and-references\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Pointers and References<a class=\"headerlink\" href=\"#pointers-and-references\" title=\"Link to this heading\">#</a></h2><p>A suffix * after a type in a declaration/definition indicates you are creating a pointer to a Name of that type.\nThe prefix * before a pointer Name means \u201ccontents of\u201d \u2013 gets the value associated with the pointer\nThe prefix &amp; before a Name means \u201caddress of\u201d \u2013 gets the address for assignment to a pointer.\nWhen used in declarations <em>,&amp;, and [] are \u201cdeclarator operators\u201d.\nThe pointer contains only the address, so &amp;Name is that address.\nTRY - Run this code more than once.\nint main() {\nstd::vector<double> myVector = { 5.9,8,1.1,2.3,4.5,5.6 };\n\u00a0\ndouble</double></em> myPointerToV;\n\u00a0\nmyPointerToV = &amp;myVector[3];\ndouble temp = *myPointerToV;\n\u00a0\nstd::cout &lt;&lt; myPointerToV &lt;&lt; \u201c\\n\u201d;\nstd::cout &lt;&lt; temp &lt;&lt; \u201c\\n\u201d;</p>", "a[href=\"#pointers\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Pointers<a class=\"headerlink\" href=\"#pointers\" title=\"Link to this heading\">#</a></h1><p>A pointer should always point at an object, so that dereferencing it is valid. When we don\u2019t have an object to point to or if we need to represent the notion of \u2018\u2018no object available\u2019\u2019 (e.g., for an end of a list), we give the pointer the value nullptr (\u2018\u2018the null pointer\u2019\u2019). There is only one nullptr shared by all pointer types:\n\u00a0\nNullptr is of type pointer.\n\u00a0\nA reference is similar to a pointer.</p><p>But instead, we put the suffix &amp; after the type in the declaration, and do not need the * to access the value.\nReferences cannot be redirected, they only refer to one object.</p>", "a[href=\"#pointers-to-functions\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Pointers to Functions<a class=\"headerlink\" href=\"#pointers-to-functions\" title=\"Link to this heading\">#</a></h2><p>Like a (data) object, the code generated for a function body is placed in memory somewhere  and therefore has a unique address associated with it and therefore we can also define a pointer to a function in a similar manner to a pointer to an object.  There are some differences however\nA pointer to function does not allow the code to be modified.\nThe pointer obtained by taking the address of a function can be used to call the function.\nvoid error(std::string s) { std::cout &lt;&lt; s; }\nvoid (*efct)(std::string); // pointer to\nfunction taking a string argument and returning nothing\nvoid f();\nvoid f()\n{\nefct = &amp;error; // efct points to error\nefct(\u201cerror\u201d); // call error through efct\n}\nvoid error(std::string s) {\nstd::cout &lt;&lt; s;\n}\nvoid (*ptrToError)(std::string);</p><p>void main() {\nptrToError = &amp;error;\nptrToError(\u201cWarning!\u201d);</p>", "a[href=\"#void\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Void<a class=\"headerlink\" href=\"#void\" title=\"Link to this heading\">#</a></h2><p>In low-level code, we occasionally need to store or pass along an address of a memory location without actually knowing what type of object is stored there. A void\u2217 is used for that. You can read void\u2217 as \u2018\u2018pointer to an object of unknown type.\u2019\u2019\nFunctions using void* pointers typically exist at the very lowest level of the system, where real hardware resources are manipulated. For example:\nvoid* my_alloc(size_t n);   // allocate n bytes from my special heap\nOccurrences of void<em>s at higher levels of the system should be viewed with great suspicion because they are likely indicators of design errors. Where used for optimization, void</em> can be hidden behind a type-safe interface.\nPointers to functions and pointers to members cannot be assigned to void* .</p>", "a[href=\"#pointer-arithmetic-and-arrays\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Pointer Arithmetic and Arrays<a class=\"headerlink\" href=\"#pointer-arithmetic-and-arrays\" title=\"Link to this heading\">#</a></h2><p>The name of an array is actually a pointer to the \ufb01rst element in the array. Writing\u00a0myArray[3]\u00a0tells the compiler to return the element that is 3 away from the starting el\u00adement of myArray. This explains why arrays are always passed by reference: passing an array is really passing a pointer.\nThis also explains why array indices start at 0: the \ufb01rst element of an array is the element that is 0 away from the start of the array\nPointer arithmetic\npointer arithmetic is a way of using subtraction and addition of pointers to move around between locations in memory, typically between array elements. Adding an integer n to a pointer produces a new pointer pointing to n positions further down in memory.\nTake the following code snippet:</p><p>long arr[] = {6,0,9,8};\nlong* ptr = arr;\nstd::cout &lt;&lt; ptr &lt;&lt; \u2018\\n\u2019;\nstd::cout &lt;&lt; <em>ptr &lt;&lt; \u2018\\n\u2019;\nptr++;\nlong</em> ptr2 = arr + 3;\nstd::cout &lt;&lt; ptr &lt;&lt; \u2018\\n\u2019;\nstd::cout &lt;&lt; *ptr &lt;&lt; \u2018\\n\u2019;\nstd::cout &lt;&lt; ptr2 &lt;&lt; \u2018\\n\u2019;\nstd::cout &lt;&lt; *ptr2 &lt;&lt; \u2018\\n\u2019;</p>"}
skip_classes = ["headerlink", "sd-stretched-link"]

window.onload = function () {
    for (const [select, tip_html] of Object.entries(selector_to_html)) {
        const links = document.querySelectorAll(` ${select}`);
        for (const link of links) {
            if (skip_classes.some(c => link.classList.contains(c))) {
                continue;
            }

            tippy(link, {
                content: tip_html,
                allowHTML: true,
                arrow: true,
                placement: 'auto-start', maxWidth: 500, interactive: false,

            });
        };
    };
    console.log("tippy tips loaded!");
};
