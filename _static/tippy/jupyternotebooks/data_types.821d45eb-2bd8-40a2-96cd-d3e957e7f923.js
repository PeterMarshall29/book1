selector_to_html = {"a[href=\"#the-structure-of-declarations\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">The Structure of Declarations<a class=\"headerlink\" href=\"#the-structure-of-declarations\" title=\"Link to this heading\">#</a></h3><p>The structure of a declaration is defined by the C++ grammar (\u00a7iso.A). This grammar evolved over four decades, starting with the early C grammars, and is quite complicated. However, without too many radical simplifications, we can consider a declaration as having five parts (in order):</p>", "a[href=\"#namespace\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Namespace<a class=\"headerlink\" href=\"#namespace\" title=\"Link to this heading\">#</a></h2><p>Namespace is a language feature exclusively used to express scoping.\nCreating a namespace allows you to write sperate parts of a longer program without fear that the names used will not have been used elsewhere.\n\u00a0\nThe standard library facilities are defined in namespace std, so to use them, you need an explicit qualification, a using declaration, or a using directive:</p><p>std::string s; // explicit qualification</p>", "a[href=\"#declaration\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Declaration<a class=\"headerlink\" href=\"#declaration\" title=\"Link to this heading\">#</a></h2><p>Before a name (identifier) can be used in a C++ program, it must be declared. That is, its type must be specified to inform the compiler what kind of entity the name refers to. For example:\nchar ch;\nstd::string s;\nauto count = 1;\nconst double pi{ 3.1415926535897 };\nextern int error_number;\nconst char* name = \u201cNjal\u201d;\nconst char* season[] = { \u201cspring\u201d, \u201csummer\u201d, \u201cfall\u201d, \u201cwinter\u201d };\nstd::vector<a class=\"reference external\" href=\"std::string\">std::string</a> people{ name, \u201cSkarphedin\u201d, \u201cGunnar\u201d };\ndouble std::sqrt(double);\nstruct Date { int d = 3, m, y; };\nint day(Date * p) { return p\u2212 &gt; d; };\ntemplate<class t=\"\"> T abs(T a) { return a &lt; 0 ? \u2212a : a; }\nconstexpr int fac(int n) { return (n &lt; 2) ? 1 : n*fac(n\u22121); } // possible compile-time evaluation (\u00a72.2.3)\nconstexpr double zz{ ii\u2217fac(7) }; // compile-time initialization</class></p><p>using Cmplx = std::complex<double>; // type alias (\u00a73.4.5, \u00a76.5)\nstruct User; // type name\nenum class Beer { Carlsberg, Tuborg, Thor };\nnamespace NS { int a; }</double></p>", "a[href=\"#fundamental-types-in-c\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Fundamental Types in C++<a class=\"headerlink\" href=\"#fundamental-types-in-c\" title=\"Link to this heading\">#</a></h2><p>The fundamental types in c++ correspond to the most common basic storage units of a computer and the most common ways of using them to hold data; these are available from the core language:\nThe boolean type: bool.\nThe character types: char, wchar_t.\nThe integer types: int, long long; quite a few of them\u2026\nThe floating-point types: double,long double.\nvoid a type used to signify the absence of information.\nThe Boolean, character, and integer types are collectively called integral types.\nThe integral and floating-point types are collectively called arithmetic types.</p><p>Other \u2018built-in\u2019 types, are constructed using declarator operators:\nThe pointer types : int*.\nThe simple array type: char[].\nThe reference type: double&amp; and vector<int>&amp;&amp;.</int></p>", "a[href=\"#lvalue-and-rvalue\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\"><code class=\"docutils literal notranslate\"><span class=\"pre\">lvalue</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">rvalue</span></code><a class=\"headerlink\" href=\"#lvalue-and-rvalue\" title=\"Link to this heading\">#</a></h2><p>The c++ term \u2018\u2018lvalue\u2019\u2019 was originally coined to mean \u2018\u2018something that can be on the left-hand side of an assignment.\u2019\u2019 \u2013 an Lvalue is any object with a memory allocation \u2013 i.e. any named object, or an unnamed objected created using new is an lvalue.\nHowever, not every lvalue may be used on the left-hand side of an assignment; e.g. an lvalue can refer to a constant. An lvalue that has not been declared const is often called a modifiable lvalue. This simple and low-level notion of an object should not be confused with the notions of class object and object of polymorphic type.\nRvalue means \u2018\u2018a value that is not an lvalue,\u2019\u2019 such as a temporary value (e.g., the value returned by a function).\nIf you need to be more technical because you want to read the ISO C++ standard a deeper definition is required. There are two properties that matter for an object when it comes to addressing, copying, and moving:\n\u2022 Has identity: The program has the name of, pointer to, or reference to the object so that it is possible to determine if two objects are the same, whether the value of the object has changed, etc.\n\u2022 Movable: The object may be moved from (i.e., we are allowed to move its value to another location and leave the object in a valid but unspecified state, rather than copying).\nFor practical programming, thinking in terms of rvalue and lvalue is usually sufficient. Note that every expression is either an lvalue or an rvalue, but not both.</p><p>It turns out that three of the four possible combinations of those two properties are needed to precisely describe the C++ language rules (we have no need for objects that do not have identity and cannot be moved). Using \u2018\u2018m for movable\u2019\u2019 and \u2018\u2018i for has identity,\u2019\u2019 we can represent this classification of expressions graphically:</p>", "a[href=\"#type-aliases\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Type Aliases<a class=\"headerlink\" href=\"#type-aliases\" title=\"Link to this heading\">#</a></h2><p>Sometimes, we need a new name for a type. Possible reasons include:</p>", "a[href=\"#scope\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Scope<a class=\"headerlink\" href=\"#scope\" title=\"Link to this heading\">#</a></h2><p>A named object is declared \u201cin scope\u201d. A \u201cscope\u201d is a region of program text, e.g. inside a single function. The object is only valid within that region of the program unless it is defined to have \u201cglobal scope\u201d.\nThe main purpose of a scope is to keep names \u201clocal\u201d, so that they won\u2019t interfere with names declared elsewhere; i.e. same names can be used in different local scopes.</p><p>Try to always use indenting to reinforce scoping changes.\n\u00a0\n\u00a0\nThere are several kinds of scopes that we use to control where our names can\nbe used:\n\u2022 The global scope: the area of text outside any other scope\n\u2022 A namespace scope: a named scope nested in the global scope or in another namespace\n\u2022 A class scope: the area of text within a class\n\u2022 A local scope: between { \u2026 } braces of a block or in a function argument list\n\u2022 A statement scope: e.g., in a for-statement</p>", "a[href=\"#scoping-problems\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Scoping Problems<a class=\"headerlink\" href=\"#scoping-problems\" title=\"Link to this heading\">#</a></h2><p>You need to keep in mind the following rules:\nA local variable will be used in preference to a global variable of the same name.\nVariables cannot be accessed outside of their scope, loop variable, function parameters only exist inside their scope. Class and struct variables can be accessed by indexing in.\nMake global variable have long detailed names.\nDo not use global variables if possible, its hard to keep track of which functions may be altering their values.\nThe quality of a program is often said to be inversely proportional to the number of global variables as the index of an exponential \u2013 keep it to one or two at most.\n\u00a0\nBlocks: Blocks within functions (nested blocks) or other block have their own scope\nFunctions: Local or nested functions\nClasses: Classes can have member classes; classes within another class, also called nested classes.\nLocal classes are those declared with in functions \u2013 best avoided \u2013 function is too long if it benefits from the use of a class.\nA member definition can be outside its class, provided it is declared inside the class.</p><p>Inside: Void f(); // declaration\nOutside: Void MyClassName::f() {} // the definition.</p>", "a[href=\"#c-data-types\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">C++ Data Types<a class=\"headerlink\" href=\"#c-data-types\" title=\"Link to this heading\">#</a></h1><p>An identifier is an arbitrarily long sequence of digits, underscores, lowercase and uppercase Latin letters, and most Unicode characters.</p><p>The first character of a valid identifier must be one of the following:</p>", "a[href=\"#deducing-a-type-auto-and-decltype\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">6.3.6 Deducing a Type: auto and decltype()<a class=\"headerlink\" href=\"#deducing-a-type-auto-and-decltype\" title=\"Link to this heading\">#</a></h2><p>C++ provides two mechanisms for deducing a type from an expression:\nauto for deducing a type of an object from its initializer; the type can be the type of a variable, a const, or a constexpr.\ndecltype(expr) for deducing the type of something that is not a simple initializer, such as the return type for a function, or the type of a class member.\nThe deduction done here is very simple: auto and decltype() simply report the type of an expression already known to the compiler.\nThere is not much advantage in using auto instead of int for an expression as simple as 123. The harder the type is to write and the harder the type is to know, the more useful auto becomes. For example:\ntemplate<class t=\"\"> void f1(std::vector<t>&amp;arg)\n{\nfor (std::vector<t>::iterator p = arg.begin(); p != arg.end(); ++p)\n*p = 7;\nfor (auto p = arg.begin(); p != arg.end(); ++p)\n*p = 7;\n}\nThe loop using auto is the more convenient to write and the easier to read. Also, it is more resilient to code changes.</t></t></class></p><p>The language provides two mechanisms for deducing a type from an expression:\nauto for deducing a type of an object from its initializer; the type can be the type of a vari- able, a const, or a constexpr.\ndecltype(expr) for deducing the type of something that is not a simple initializer, such as the return type for a function or the type of a class member.\nThe deduction done here is very simple: auto and decltype() simply report the type of an expression already known to the compiler.</p>", "a[href=\"#types-and-declarations\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Types and Declarations<a class=\"headerlink\" href=\"#types-and-declarations\" title=\"Link to this heading\">#</a></h2><p>For the compiler to make sense of the C++ code you have written, every named object must have a type, and be declared before use, and the types declared must have associate methods that match those used.</p><p>variable1 = variable2 + myFunction(variable3);</p>", "a[href=\"#introductory\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Introductory<a class=\"headerlink\" href=\"#introductory\" title=\"Link to this heading\">#</a></h2><p>Try to fix this code:</p><p>std::int age = 52;\nstd::string firstName = 12.0;\nstd::float = 12.5;</p>"}
skip_classes = ["headerlink", "sd-stretched-link"]

window.onload = function () {
    for (const [select, tip_html] of Object.entries(selector_to_html)) {
        const links = document.querySelectorAll(` ${select}`);
        for (const link of links) {
            if (skip_classes.some(c => link.classList.contains(c))) {
                continue;
            }

            tippy(link, {
                content: tip_html,
                allowHTML: true,
                arrow: true,
                placement: 'auto-start', maxWidth: 500, interactive: false,

            });
        };
    };
    console.log("tippy tips loaded!");
};
