selector_to_html = {"a[href=\"#deducing-a-type-auto-and-decltype\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">6.3.6 Deducing a Type: auto and decltype()<a class=\"headerlink\" href=\"#deducing-a-type-auto-and-decltype\" title=\"Permalink to this heading\">#</a></h2><p>C++ provides two mechanisms for deducing a type from an expression:\nauto for deducing a type of an object from its initializer; the type can be the type of a variable, a const, or a constexpr.\ndecltype(expr) for deducing the type of something that is not a simple initializer, such as the return type for a function, or the type of a class member.\nThe deduction done here is very simple: auto and decltype() simply report the type of an expression already known to the compiler.\nThere is not much advantage in using auto instead of int for an expression as simple as 123. The harder the type is to write and the harder the type is to know, the more useful auto becomes. For example:\ntemplate<class t=\"\"> void f1(std::vector<t>&amp;arg)\n{\nfor (std::vector<t>::iterator p = arg.begin(); p != arg.end(); ++p)\n*p = 7;\nfor (auto p = arg.begin(); p != arg.end(); ++p)\n*p = 7;\n}\nThe loop using auto is the more convenient to write and the easier to read. Also, it is more resilient to code changes.</t></t></class></p><p>The language provides two mechanisms for deducing a type from an expression:\nauto for deducing a type of an object from its initializer; the type can be the type of a vari- able, a const, or a constexpr.\ndecltype(expr) for deducing the type of something that is not a simple initializer, such as the return type for a function or the type of a class member.\nThe deduction done here is very simple: auto and decltype() simply report the type of an expression already known to the compiler.</p>", "a[href=\"glossary.html#term-Entities\"]": "<dt id=\"term-Entities\">Entities</dt><dd><p>The entities of a C++ program are values, objects, references, functions, enumerators, types, class members, templates, template specializations, and namespaces. ECS consists of three main parts:</p></dd>", "a[href=\"#type-aliases\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Type Aliases<a class=\"headerlink\" href=\"#type-aliases\" title=\"Permalink to this heading\">#</a></h2><p>Sometimes, we need a new name for a type. Possible reasons include:</p>", "a[href=\"glossary.html#term-Objects\"]": "<dt id=\"term-Objects\">Objects</dt><dd></dd>", "a[href=\"#fundamental-types-in-c\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Fundamental Types in C++<a class=\"headerlink\" href=\"#fundamental-types-in-c\" title=\"Permalink to this heading\">#</a></h2><p>The fundamental types in c++ correspond to the most common basic storage units of a computer and the most common ways of using them to hold data; these are available from the core language:\nThe boolean type: bool.\nThe character types: char, wchar_t.\nThe integer types: int, long long; quite a few others\u2026\nThe floating-point types: double,long double.\nvoid a type used to signify the absence of information.\nThe Boolean, character, and integer types are collectively called integral types.\nThe integral and floating-point types are collectively called arithmetic types.</p><p>Other \u2018built-in\u2019 types, are constructed using declarator operators:\nThe pointer types : <code class=\"docutils literal notranslate\"><span class=\"pre\">int*</span></code>.\nThe simple array type: <code class=\"docutils literal notranslate\"><span class=\"pre\">char[]</span></code>.\nThe reference type: <code class=\"docutils literal notranslate\"><span class=\"pre\">double&amp;</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">vector&lt;int&gt;&amp;&amp;</span></code>.</p>", "a[href=\"glossary.html#term-Class\"]": "<dt id=\"term-Class\">Class</dt><dd><p>more basic    ;A blueprint for creating objects, encapsulating data (attributes) and functions (methods).</p></dd>", "a[href=\"#lvalue-and-rvalue\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\"><code class=\"docutils literal notranslate\"><span class=\"pre\">lvalue</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">rvalue</span></code><a class=\"headerlink\" href=\"#lvalue-and-rvalue\" title=\"Permalink to this heading\">#</a></h2><p>The c++ term \u2018\u2018lvalue\u2019\u2019 was originally coined to mean \u2018\u2018something that can be on the left-hand side of an assignment.\u2019\u2019 \u2013 an Lvalue is any object with a memory allocation \u2013 i.e. any named object, or an unnamed objected created using new is an lvalue.\nHowever, not every lvalue may be used on the left-hand side of an assignment; e.g. an lvalue can refer to a constant. An lvalue that has not been declared const is often called a modifiable lvalue. This simple and low-level notion of an object should not be confused with the notions of class object and object of polymorphic type.\nRvalue means \u2018\u2018a value that is not an lvalue,\u2019\u2019 such as a temporary value (e.g., the value returned by a function).\nIf you need to be more technical because you want to read the ISO C++ standard a deeper definition is required. There are two properties that matter for an object when it comes to addressing, copying, and moving:\n\u2022 Has identity: The program has the name of, pointer to, or reference to the object so that it is possible to determine if two objects are the same, whether the value of the object has changed, etc.\n\u2022 Movable: The object may be moved from (i.e., we are allowed to move its value to another location and leave the object in a valid but unspecified state, rather than copying).\nFor practical programming, thinking in terms of rvalue and lvalue is usually sufficient. Note that every expression is either an lvalue or an rvalue, but not both.</p><p>It turns out that three of the four possible combinations of those two properties are needed to precisely describe the C++ language rules (we have no need for objects that do not have identity and cannot be moved). Using \u2018\u2018m for movable\u2019\u2019 and \u2018\u2018i for has identity,\u2019\u2019 we can represent this classification of expressions graphically:</p>", "a[href=\"#the-structure-of-declarations\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">The Structure of Declarations<a class=\"headerlink\" href=\"#the-structure-of-declarations\" title=\"Permalink to this heading\">#</a></h3><p>The structure of a declaration is defined by the C++ grammar (\u00a7iso.A). This grammar evolved over four decades, starting with the early C grammars, and is quite complicated. However, without too many radical simplifications, we can consider a declaration as having five parts (in order):</p>", "a[href=\"#objects-values-and-types\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Objects, Values, and Types<a class=\"headerlink\" href=\"#objects-values-and-types\" title=\"Permalink to this heading\">#</a></h1><p>Copied</p><p>Certain words in a C++ program have special meaning, and these are known as keywords. Others can be used as identifiers. Comments are ignored during translation. C++ programs also contain literals, the values of characters inside them are determined by character sets and encodings. Certain characters in the program have to be represented with escape sequences.</p>", "a[href=\"#types-and-declarations\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Types and Declarations<a class=\"headerlink\" href=\"#types-and-declarations\" title=\"Permalink to this heading\">#</a></h2><p>For the compiler to make sense of the C++ code you have written, every named object must have a type, and be declared before use, and the types declared must have associated methods that match those you try to use.</p><p><code class=\"docutils literal notranslate\"><span class=\"pre\">variable1</span> <span class=\"pre\">=</span> <span class=\"pre\">variable2</span> <span class=\"pre\">+</span> <span class=\"pre\">myFunction(variable3);</span></code></p>", "a[href=\"#declaration-from-cppreference\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">declaration from cppreference<a class=\"headerlink\" href=\"#declaration-from-cppreference\" title=\"Permalink to this heading\">#</a></h2><p>Declarations are how names are introduced (or re-introduced) into the C++ program. Not all declarations actually declare anything, and each kind of entity is declared differently. Definitions are declarations that are sufficient to use the entity identified by the name.</p><p>A declaration is one of the following:</p>", "a[href=\"#declaration\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Declaration<a class=\"headerlink\" href=\"#declaration\" title=\"Permalink to this heading\">#</a></h2><p>Before a name (identifier) can be used in a C++ program, it must be declared. That is, its type must be specified to inform the compiler what kind of entity the name refers to. For example:\nchar ch;\nstd::string s;\nauto count = 1;\nconst double pi{ 3.1415926535897 };\nextern int error_number;\nconst char* name = \u201cNjal\u201d;\nconst char* season[] = { \u201cspring\u201d, \u201csummer\u201d, \u201cfall\u201d, \u201cwinter\u201d };\nstd::vector<a class=\"reference external\" href=\"std::string\">std::string</a> people{ name, \u201cSkarphedin\u201d, \u201cGunnar\u201d };\ndouble std::sqrt(double);\nstruct Date { int d = 3, m, y; };\nint day(Date * p) { return p\u2212 &gt; d; };\ntemplate<class t=\"\"> T abs(T a) { return a &lt; 0 ? \u2212a : a; }\nconstexpr int fac(int n) { return (n &lt; 2) ? 1 : n*fac(n\u22121); } // possible compile-time evaluation (\u00a72.2.3)\nconstexpr double zz{ ii\u2217fac(7) }; // compile-time initialization</class></p><p>using Cmplx = std::complex<double>; // type alias (\u00a73.4.5, \u00a76.5)\nstruct User; // type name\nenum class Beer { Carlsberg, Tuborg, Thor };\nnamespace NS { int a; }</double></p>", "a[href=\"#identifiers\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Identifiers<a class=\"headerlink\" href=\"#identifiers\" title=\"Permalink to this heading\">#</a></h2><p>An identifier is an arbitrarily long sequence of digits, underscores, lowercase and uppercase Latin letters, and most Unicode characters.</p><p>\u201cName\u201d is generally synonymous with \u201cidentifier\u201d - the exceptions are beyond the scope of this book.</p>", "a[href=\"#objects-and-variables\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Objects and Variables<a class=\"headerlink\" href=\"#objects-and-variables\" title=\"Permalink to this heading\">#</a></h2><p>An <strong>object</strong> is a region of memory with a <strong>type</strong> that specifies what kind of information can be placed in it.</p><p>The object is a region of memory holding a value of a specified type.</p>"}
skip_classes = ["headerlink", "sd-stretched-link"]

window.onload = function () {
    for (const [select, tip_html] of Object.entries(selector_to_html)) {
        const links = document.querySelectorAll(` ${select}`);
        for (const link of links) {
            if (skip_classes.some(c => link.classList.contains(c))) {
                continue;
            }

            tippy(link, {
                content: tip_html,
                allowHTML: true,
                arrow: true,
                placement: 'auto-start', maxWidth: 500, interactive: false, theme: 'material', duration: [200, 100], delay: [200, 0],

            });
        };
    };
    console.log("tippy tips loaded!");
};
